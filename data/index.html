<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>MiniLabBox</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 1em; }
    table { border-collapse: collapse; width: 100%; margin-bottom: 1em; }
    th, td { border: 1px solid #ccc; padding: 0.3em 0.5em; text-align: left; }
    tr:nth-child(even) { background-color: #f8f8f8; }
    h1 { margin-top: 0; }
    a { color: #0066cc; text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
  <script src="auth.js"></script>
</head>
<body>
<h1>MiniLabBox Node</h1>
<p>Identifiant du nœud : <strong><span id="nodeId"></span></strong></p>

<h2>Entrées</h2>
<table id="inputsTable">
  <thead>
    <tr><th>Nom</th><th>Valeur</th><th>Unité</th></tr>
  </thead>
  <tbody></tbody>
</table>

<h2>Sorties</h2>
<table id="outputsTable">
  <thead>
    <tr><th>Nom</th><th>Valeur</th><th>Définir</th></tr>
  </thead>
  <tbody></tbody>
</table>

<p>
  <a href="config.html">Configurer le système</a> |
  <a href="example.html">Exemple de mesure de puissance</a> |
  <a href="logs.html">Logs système</a> |
  <a href="editor.html">Éditeur de fichiers</a>
</p>

<script>
let configuredInputs = [];
let configuredOutputs = [];
const inputRowMap = new Map();
const outputRowMap = new Map();

function normaliseNumber(value) {
  if (value === null || value === undefined) {
    return null;
  }
  const num = typeof value === 'number' ? value : parseFloat(value);
  if (!Number.isFinite(num)) {
    return null;
  }
  return num;
}

function formatDisplayValue(value) {
  const num = normaliseNumber(value);
  return num === null ? '—' : num.toFixed(3);
}

function renderEmptyRow(tbody, message, colspan) {
  const row = document.createElement('tr');
  row.classList.add('empty-row');
  const cell = document.createElement('td');
  cell.colSpan = colspan;
  cell.textContent = message;
  row.appendChild(cell);
  tbody.appendChild(row);
}

function normaliseConfiguredInput(item) {
  if (!item) return null;
  const name = (item.name || '').toString();
  if (!name) return null;
  const type = (item.type || '').toString().toLowerCase();
  const unit = item.unit ? item.unit.toString() : '';
  const active = !!item.active && type !== 'disabled';
  return { name, unit, active };
}

function normaliseConfiguredOutput(item) {
  if (!item) return null;
  const name = (item.name || '').toString();
  if (!name) return null;
  const type = (item.type || '').toString().toLowerCase();
  const active = !!item.active && type !== 'disabled';
  const value = normaliseNumber(item.value);
  return { name, active, value };
}

function renderConfiguredInputs() {
  const tbody = document.querySelector('#inputsTable tbody');
  if (!tbody) return;
  inputRowMap.clear();
  tbody.innerHTML = '';
  const activeInputs = configuredInputs.filter(item => item && item.active);
  if (activeInputs.length === 0) {
    renderEmptyRow(tbody, 'Aucune entrée active.', 3);
    return;
  }
  activeInputs.forEach(item => {
    const tr = document.createElement('tr');
    tr.dataset.name = item.name;
    const tdName = document.createElement('td');
    tdName.textContent = item.name;
    const tdVal = document.createElement('td');
    tdVal.textContent = '—';
    const tdUnit = document.createElement('td');
    tdUnit.textContent = item.unit || '';
    const rowInfo = {
      valueCell: tdVal,
      unitCell: tdUnit,
      defaultUnit: item.unit || ''
    };
    tr.appendChild(tdName);
    tr.appendChild(tdVal);
    tr.appendChild(tdUnit);
    tbody.appendChild(tr);
    inputRowMap.set(item.name, rowInfo);
  });
}

function renderConfiguredOutputs() {
  const tbody = document.querySelector('#outputsTable tbody');
  if (!tbody) return;
  outputRowMap.clear();
  tbody.innerHTML = '';
  const activeOutputs = configuredOutputs.filter(item => item && item.active);
  if (activeOutputs.length === 0) {
    renderEmptyRow(tbody, 'Aucune sortie active.', 3);
    return;
  }
  activeOutputs.forEach(item => {
    const tr = document.createElement('tr');
    tr.dataset.name = item.name;
    const tdName = document.createElement('td');
    tdName.textContent = item.name;
    const tdVal = document.createElement('td');
    tdVal.textContent = formatDisplayValue(item.value);
    const tdSet = document.createElement('td');
    const input = document.createElement('input');
    input.type = 'number';
    input.step = '0.1';
    const initialValue = item.value;
    if (initialValue !== null) {
      input.value = initialValue;
    } else {
      input.value = '';
    }
    const rowInfo = {
      valueCell: tdVal,
      inputEl: input,
      lastValue: initialValue
    };
    input.addEventListener('change', () => {
      const numeric = normaliseNumber(input.value);
      if (numeric === null) {
        if (rowInfo.lastValue !== null) {
          input.value = rowInfo.lastValue;
        } else {
          input.value = '';
        }
        return;
      }
      rowInfo.lastValue = numeric;
      setOutput(item.name, numeric);
    });
    tdSet.appendChild(input);
    tr.appendChild(tdName);
    tr.appendChild(tdVal);
    tr.appendChild(tdSet);
    tbody.appendChild(tr);
    outputRowMap.set(item.name, rowInfo);
  });
}

// Récupère la configuration pour afficher l'identifiant du nœud et préparer les tables
async function loadConfig() {
  try {
    const resp = await authFetch('/api/config/get');
    if (!resp.ok) return;
    const cfg = await resp.json();
    const nodeEl = document.getElementById('nodeId');
    if (nodeEl) {
      nodeEl.innerText = cfg.nodeId || '';
    }
    configuredInputs = Array.isArray(cfg.inputs)
      ? cfg.inputs.map(normaliseConfiguredInput).filter(Boolean)
      : [];
    configuredOutputs = Array.isArray(cfg.outputs)
      ? cfg.outputs.map(normaliseConfiguredOutput).filter(Boolean)
      : [];
    renderConfiguredInputs();
    renderConfiguredOutputs();
  } catch (err) {
    console.error(err);
  }
}

// Rafraîchit les valeurs des entrées et sorties
async function loadValues() {
  try {
    const [inResp, outResp] = await Promise.all([
      authFetch('/api/inputs'),
      authFetch('/api/outputs')
    ]);
    if (inResp.ok) {
      const data = await inResp.json();
      const list = Array.isArray(data.inputs) ? data.inputs : [];
      inputRowMap.forEach(info => {
        info.valueCell.textContent = '—';
        info.unitCell.textContent = info.defaultUnit || '';
      });
      list.forEach(item => {
        if (!item || !item.name) return;
        const rowInfo = inputRowMap.get(item.name);
        if (!rowInfo) return;
        rowInfo.valueCell.textContent = formatDisplayValue(item.value);
        const unit = (typeof item.unit === 'string' && item.unit.length > 0)
          ? item.unit
          : rowInfo.defaultUnit || '';
        rowInfo.unitCell.textContent = unit;
      });
    }
    if (outResp.ok) {
      const data = await outResp.json();
      const list = Array.isArray(data.outputs) ? data.outputs : [];
      list.forEach(item => {
        if (!item || !item.name) return;
        const rowInfo = outputRowMap.get(item.name);
        if (!rowInfo) return;
        rowInfo.valueCell.textContent = formatDisplayValue(item.value);
        const numeric = normaliseNumber(item.value);
        if (numeric !== null) {
          rowInfo.inputEl.value = numeric;
          rowInfo.lastValue = numeric;
        }
        if (item.active === false) {
          rowInfo.inputEl.disabled = true;
        } else {
          rowInfo.inputEl.disabled = false;
        }
      });
    }
  } catch (err) {
    console.error(err);
  }
}

// Envoie une nouvelle valeur pour une sortie
function setOutput(name, value) {
  authFetch('/api/output/set', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ name: name, value: value })
  }).catch(err => console.error(err));
}

window.addEventListener('DOMContentLoaded', () => {
  ensureSession()
    .then(async () => {
      await loadConfig();
      await loadValues();
      setInterval(loadValues, 1000);
    })
    .catch(err => {
      console.error(err);
    });
});
</script>
</body>
</html>