<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>MiniLabBox</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 1em; }
    table { border-collapse: collapse; width: 100%; margin-bottom: 1em; }
    th, td { border: 1px solid #ccc; padding: 0.3em 0.5em; text-align: left; }
    tr:nth-child(even) { background-color: #f8f8f8; }
    h1 { margin-top: 0; }
    a { color: #0066cc; text-decoration: none; }
    a:hover { text-decoration: underline; }
    .hint { font-size: 0.9em; color: #555; margin: 0.2em 0 1em; }
    .status-message { font-size: 0.9em; color: #555; min-height: 1.2em; }
    .status-message.error { color: #c0392b; }
    #privateFilesTable .empty-row td { text-align: center; color: #666; font-style: italic; }
    .virtual-lab-entry {
      margin: 1.5em 0 2.5em;
      display: flex;
      align-items: center;
      gap: 1.5em;
      padding: 1em 1.5em;
      border: 1px solid #d0e6ff;
      border-radius: 16px;
      background: linear-gradient(120deg, rgba(10, 109, 216, 0.05), rgba(69, 209, 255, 0.05));
      box-shadow: 0 8px 20px rgba(10, 109, 216, 0.08);
    }
    .virtual-lab-entry img {
      width: 96px;
      height: auto;
      display: block;
    }
    .virtual-lab-entry .virtual-lab-title {
      display: inline-flex;
      align-items: center;
      gap: 0.6em;
      font-size: 1.2em;
      font-weight: 700;
      color: #0a6dd8;
    }
    .virtual-lab-entry .virtual-lab-title:hover {
      color: #06488f;
    }
    .virtual-lab-entry p {
      margin: 0.3em 0 0;
      color: #344055;
      max-width: 460px;
      line-height: 1.4;
    }
  </style>
  <script src="auth.js"></script>
</head>
<body>
<h1>MiniLabBox Node</h1>
<p>Identifiant du nœud : <strong><span id="nodeId"></span></strong></p>

<div class="virtual-lab-entry">
  <a href="virtual-lab/index.html" aria-label="Accéder au Virtual Lab">
    <img src="assets/virtual-lab-logo.svg" alt="Logo Virtual Lab">
  </a>
  <div>
    <a class="virtual-lab-title" href="virtual-lab/index.html">
      Accéder au Virtual Lab professionnel
    </a>
    <p>Un environnement immersif regroupant oscilloscope Tektronix, multimètre de laboratoire et générateur de fonctions.</p>
    <p>
      <a href="virtual-lab/settings.html">Configurer les appareils virtuels</a>
    </p>
  </div>
</div>

<h2>Entrées</h2>
<table id="inputsTable">
  <thead>
    <tr><th>Nom</th><th>Valeur</th><th>Unité</th></tr>
  </thead>
  <tbody></tbody>
</table>

<h2>Sorties</h2>
<table id="outputsTable">
  <thead>
    <tr><th>Nom</th><th>Valeur</th><th>Définir</th></tr>
  </thead>
  <tbody></tbody>
</table>

<p>
  <a href="config.html">Configurer le système</a> |
  <a href="private/power-monitor.html">Mesure de puissance</a> |
  <a href="private/io-exemples.html">Bibliothèque d'exemples IO</a> |
  <a href="logs.html">Logs système</a> |
  <a href="editor.html">Éditeur de fichiers</a> |
  <a href="virtual-lab/index.html">Virtual Lab</a> |
  <a href="virtual-lab/settings.html">Réglages Virtual Lab</a>
</p>

<h2>Fichiers HTML privés</h2>
<p class="hint">Ces fichiers résident dans <code>/private</code> et peuvent être modifiés via l'éditeur de fichiers.</p>
<table id="privateFilesTable">
  <thead>
    <tr><th>Fichier</th><th>Taille</th></tr>
  </thead>
  <tbody></tbody>
</table>
<p class="status-message" id="privateFilesStatus" aria-live="polite"></p>

<script>
let configuredInputs = [];
let configuredOutputs = [];
const inputRowMap = new Map();
const outputRowMap = new Map();
let privateFilesTimer = null;

function normaliseNumber(value) {
  if (value === null || value === undefined) {
    return null;
  }
  const num = typeof value === 'number' ? value : parseFloat(value);
  if (!Number.isFinite(num)) {
    return null;
  }
  return num;
}

function formatDisplayValue(value) {
  const num = normaliseNumber(value);
  return num === null ? '—' : num.toFixed(3);
}

function formatFileSize(bytes) {
  if (typeof bytes !== 'number' || !Number.isFinite(bytes)) {
    return '—';
  }
  if (bytes >= 1024 * 1024) {
    return `${(bytes / (1024 * 1024)).toFixed(1)} Mo`;
  }
  if (bytes >= 1024) {
    return `${(bytes / 1024).toFixed(1)} Ko`;
  }
  return `${bytes} o`;
}

function renderEmptyRow(tbody, message, colspan) {
  const row = document.createElement('tr');
  row.classList.add('empty-row');
  const cell = document.createElement('td');
  cell.colSpan = colspan;
  cell.textContent = message;
  row.appendChild(cell);
  tbody.appendChild(row);
}

function setPrivateFilesStatus(text, type = '') {
  const statusEl = document.getElementById('privateFilesStatus');
  if (!statusEl) return;
  statusEl.textContent = text || '';
  statusEl.classList.remove('error');
  if (type) {
    statusEl.classList.add(type);
  }
}

function normaliseConfiguredInput(item) {
  if (!item) return null;
  const name = (item.name || '').toString();
  if (!name) return null;
  const type = (item.type || '').toString().toLowerCase();
  const unit = item.unit ? item.unit.toString() : '';
  const active = !!item.active && type !== 'disabled';
  return { name, unit, active };
}

function normaliseConfiguredOutput(item) {
  if (!item) return null;
  const name = (item.name || '').toString();
  if (!name) return null;
  const type = (item.type || '').toString().toLowerCase();
  const active = !!item.active && type !== 'disabled';
  const value = normaliseNumber(item.value);
  return { name, active, value };
}

function renderConfiguredInputs() {
  const tbody = document.querySelector('#inputsTable tbody');
  if (!tbody) return;
  inputRowMap.clear();
  tbody.innerHTML = '';
  const activeInputs = configuredInputs.filter(item => item && item.active);
  if (activeInputs.length === 0) {
    renderEmptyRow(tbody, 'Aucune entrée active.', 3);
    return;
  }
  activeInputs.forEach(item => {
    const tr = document.createElement('tr');
    tr.dataset.name = item.name;
    const tdName = document.createElement('td');
    tdName.textContent = item.name;
    const tdVal = document.createElement('td');
    tdVal.textContent = '—';
    const tdUnit = document.createElement('td');
    tdUnit.textContent = item.unit || '';
    const rowInfo = {
      valueCell: tdVal,
      unitCell: tdUnit,
      defaultUnit: item.unit || ''
    };
    tr.appendChild(tdName);
    tr.appendChild(tdVal);
    tr.appendChild(tdUnit);
    tbody.appendChild(tr);
    inputRowMap.set(item.name, rowInfo);
  });
}

function renderConfiguredOutputs() {
  const tbody = document.querySelector('#outputsTable tbody');
  if (!tbody) return;
  outputRowMap.clear();
  tbody.innerHTML = '';
  const activeOutputs = configuredOutputs.filter(item => item && item.active);
  if (activeOutputs.length === 0) {
    renderEmptyRow(tbody, 'Aucune sortie active.', 3);
    return;
  }
  activeOutputs.forEach(item => {
    const tr = document.createElement('tr');
    tr.dataset.name = item.name;
    const tdName = document.createElement('td');
    tdName.textContent = item.name;
    const tdVal = document.createElement('td');
    tdVal.textContent = formatDisplayValue(item.value);
    const tdSet = document.createElement('td');
    const input = document.createElement('input');
    input.type = 'number';
    input.step = '0.1';
    const initialValue = item.value;
    if (initialValue !== null) {
      input.value = initialValue;
    } else {
      input.value = '';
    }
    const rowInfo = {
      valueCell: tdVal,
      inputEl: input,
      lastValue: initialValue
    };
    input.addEventListener('change', () => {
      const numeric = normaliseNumber(input.value);
      if (numeric === null) {
        if (rowInfo.lastValue !== null) {
          input.value = rowInfo.lastValue;
        } else {
          input.value = '';
        }
        return;
      }
      rowInfo.lastValue = numeric;
      setOutput(item.name, numeric);
    });
    tdSet.appendChild(input);
    tr.appendChild(tdName);
    tr.appendChild(tdVal);
    tr.appendChild(tdSet);
    tbody.appendChild(tr);
    outputRowMap.set(item.name, rowInfo);
  });
}

function renderPrivateFiles(files) {
  const tbody = document.querySelector('#privateFilesTable tbody');
  if (!tbody) return;
  tbody.innerHTML = '';
  if (!Array.isArray(files) || files.length === 0) {
    renderEmptyRow(tbody, 'Aucun fichier HTML disponible.', 2);
    return;
  }
  files.forEach(file => {
    if (!file || typeof file.name !== 'string') {
      return;
    }
    const tr = document.createElement('tr');
    const tdName = document.createElement('td');
    const link = document.createElement('a');
    link.textContent = file.name;
    link.href = `/private/${encodeURIComponent(file.name)}`;
    link.target = '_blank';
    link.rel = 'noopener';
    tdName.appendChild(link);
    const tdSize = document.createElement('td');
    tdSize.textContent = formatFileSize(file.size);
    tr.appendChild(tdName);
    tr.appendChild(tdSize);
    tbody.appendChild(tr);
  });
}

async function loadPrivateHtmlFiles() {
  try {
    const resp = await authFetch('/api/files/list');
    if (!resp.ok) {
      const text = await resp.text();
      throw new Error(text || 'Chargement des fichiers privés impossible');
    }
    const data = await resp.json();
    const files = Array.isArray(data.files) ? data.files : [];
    const htmlFiles = files.filter(item => item && typeof item.name === 'string' && item.name.toLowerCase().endsWith('.html'));
    htmlFiles.sort((a, b) => a.name.localeCompare(b.name, 'fr', { sensitivity: 'base' }));
    renderPrivateFiles(htmlFiles);
    setPrivateFilesStatus('');
  } catch (err) {
    console.error(err);
    setPrivateFilesStatus(err.message || 'Impossible de charger les fichiers du répertoire privé.', 'error');
  }
}

// Récupère la configuration pour afficher l'identifiant du nœud et préparer les tables
async function loadConfig() {
  try {
    const resp = await authFetch('/api/config/get');
    if (!resp.ok) return;
    const cfg = await resp.json();
    const nodeEl = document.getElementById('nodeId');
    if (nodeEl) {
      nodeEl.innerText = cfg.nodeId || '';
    }
    configuredInputs = Array.isArray(cfg.inputs)
      ? cfg.inputs.map(normaliseConfiguredInput).filter(Boolean)
      : [];
    configuredOutputs = Array.isArray(cfg.outputs)
      ? cfg.outputs.map(normaliseConfiguredOutput).filter(Boolean)
      : [];
    renderConfiguredInputs();
    renderConfiguredOutputs();
  } catch (err) {
    console.error(err);
  }
}

// Rafraîchit les valeurs des entrées et sorties
async function loadValues() {
  try {
    const [inResp, outResp] = await Promise.all([
      authFetch('/api/inputs'),
      authFetch('/api/outputs')
    ]);
    if (inResp.ok) {
      const data = await inResp.json();
      const list = Array.isArray(data.inputs) ? data.inputs : [];
      inputRowMap.forEach(info => {
        info.valueCell.textContent = '—';
        info.unitCell.textContent = info.defaultUnit || '';
      });
      list.forEach(item => {
        if (!item || !item.name) return;
        const rowInfo = inputRowMap.get(item.name);
        if (!rowInfo) return;
        rowInfo.valueCell.textContent = formatDisplayValue(item.value);
        const unit = (typeof item.unit === 'string' && item.unit.length > 0)
          ? item.unit
          : rowInfo.defaultUnit || '';
        rowInfo.unitCell.textContent = unit;
      });
    }
    if (outResp.ok) {
      const data = await outResp.json();
      const list = Array.isArray(data.outputs) ? data.outputs : [];
      list.forEach(item => {
        if (!item || !item.name) return;
        const rowInfo = outputRowMap.get(item.name);
        if (!rowInfo) return;
        rowInfo.valueCell.textContent = formatDisplayValue(item.value);
        const numeric = normaliseNumber(item.value);
        if (numeric !== null) {
          rowInfo.inputEl.value = numeric;
          rowInfo.lastValue = numeric;
        }
        if (item.active === false) {
          rowInfo.inputEl.disabled = true;
        } else {
          rowInfo.inputEl.disabled = false;
        }
      });
    }
  } catch (err) {
    console.error(err);
  }
}

// Envoie une nouvelle valeur pour une sortie
function setOutput(name, value) {
  authFetch('/api/output/set', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ name: name, value: value })
  }).catch(err => console.error(err));
}

window.addEventListener('DOMContentLoaded', () => {
  ensureSession()
    .then(async () => {
      await loadConfig();
      await Promise.all([
        loadValues(),
        loadPrivateHtmlFiles()
      ]);
      setInterval(loadValues, 1000);
      if (privateFilesTimer) {
        clearInterval(privateFilesTimer);
      }
      privateFilesTimer = setInterval(loadPrivateHtmlFiles, 10000);
    })
    .catch(err => {
      console.error(err);
      setPrivateFilesStatus('Impossible de vérifier la session.', 'error');
    });
});
</script>
</body>
</html>
