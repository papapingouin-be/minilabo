<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Configuration MiniLabBox</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 1em; }
    h1 { margin-top: 0; }
    fieldset { border: 1px solid #ccc; padding: 1em; margin-bottom: 1em; }
    legend { font-weight: bold; }
    table { border-collapse: collapse; width: 100%; margin-top: 0.5em; }
    th, td { border: 1px solid #ccc; padding: 0.3em 0.5em; }
    tr:nth-child(even) { background-color: #f8f8f8; }
    input[type="number"] { width: 80px; }
    input[type="text"] { width: 120px; }
    select { width: 120px; }
    .small { width: 60px; }
    .hidden { display: none; }
    label.inline { display: inline-block; margin-right: 0.5em; }
    button { padding: 0.5em 1em; font-size: 1em; }
    button.primary { background: #1f3a93; border: none; color: #fff; }
    button.primary:hover { background: #152d6d; color: #fff; }
    #cacheAceStatus { margin-top: 0.5em; color: #555; font-size: 0.9em; }
    #cacheAceStatus.error { color: #c0392b; }
    .hint { font-size: 0.9em; color: #555; margin-top: 0.3em; }
    input.peer-pin { width: 70px; text-align: center; }
    .io-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.6em; }
    .counter { font-size: 0.9em; color: #555; }
    .io-list { display: grid; gap: 0.75em; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); }
    .io-card { border: 1px solid #d0d0d0; border-radius: 8px; padding: 0.75em 0.9em; background: #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.08); display: flex; flex-direction: column; }
    .io-card-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 0.5em; }
    .io-card h3 { margin: 0; font-size: 1.1em; }
    .io-type { font-size: 0.85em; color: #555; text-transform: uppercase; letter-spacing: 0.05em; }
    .io-details { margin: 0.5em 0 0; padding-left: 1.1em; color: #333; }
    .io-details li { margin-bottom: 0.2em; }
    .io-empty { font-style: italic; color: #666; }
    .toggle { font-size: 0.85em; color: #333; }
    .toggle input { margin-right: 0.35em; }
    .io-status { display: inline-flex; align-items: center; gap: 0.3em; font-size: 0.8em; color: #666; margin-top: 0.2em; }
    .io-status::before { content: ''; display: inline-block; width: 0.55em; height: 0.55em; border-radius: 50%; background: #bbb; }
    .io-status.synced { color: #256029; }
    .io-status.synced::before { background: #27ae60; }
    .io-status.pending { color: #8a6d3b; }
    .io-status.pending::before { background: #f1c40f; }
    .io-status.error { color: #c0392b; }
    .io-status.error::before { background: #c0392b; }
    .io-actions { margin-top: auto; display: flex; gap: 0.5em; justify-content: flex-end; }
    button.secondary { background: #f3f3f3; border: 1px solid #bbb; color: #333; }
    button.danger { background: #c0392b; border: none; color: #fff; }
    button.secondary:hover { background: #e6e6e6; }
    button.danger:hover { background: #a93124; }
    button.attention { background: #27ae60; border: none; color: #fff; }
    button.attention:hover { background: #1e8449; color: #fff; }
    .form-actions { display: flex; align-items: center; gap: 0.75em; margin-top: 1.2em; flex-wrap: wrap; }
    .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.35); display: flex; align-items: center; justify-content: center; z-index: 1000; }
    .modal.hidden { display: none; }
    .modal-content { background: #fff; padding: 1.4em 1.6em; border-radius: 10px; width: min(500px, 90%); max-height: 90vh; overflow-y: auto; box-shadow: 0 18px 40px rgba(0,0,0,0.2); }
    .modal-content h2 { margin-top: 0; }
    .modal-form-row { margin-bottom: 0.75em; display: flex; flex-direction: column; }
    .modal-form-row label { font-weight: bold; margin-bottom: 0.35em; }
    .modal-form-row input[type="text"],
    .modal-form-row input[type="number"],
    .modal-form-row select { width: 100%; box-sizing: border-box; }
    .modal-actions { display: flex; justify-content: flex-end; gap: 0.6em; margin-top: 1.2em; }
    .modal-description { font-size: 0.9em; color: #555; margin-bottom: 0.9em; }
    .modal-info { background: #f2f6ff; border-left: 4px solid #3a6abf; padding: 0.75em 1em; border-radius: 6px; color: #2a3a55; font-size: 0.9em; margin-bottom: 1em; }
    .modal-info h3 { margin: 0 0 0.35em; font-size: 1em; }
    .modal-info ul { margin: 0.4em 0 0 1.2em; padding: 0; }
    .modal-info li { margin-bottom: 0.3em; }
    button.small { padding: 0.35em 0.75em; font-size: 0.85em; }
    .progress-list { list-style: none; margin: 0; padding: 0.6em 0.8em; border: 1px solid #d0d0d0; border-radius: 6px; max-height: 260px; overflow-y: auto; background: #fafafa; }
    .progress-list li { margin: 0.35em 0; font-size: 0.9em; display: flex; align-items: center; gap: 0.4em; color: #2c3e50; }
    .progress-list li::before { content: '•'; color: #7f8c8d; }
    .progress-list li.progress-start { color: #2c3e50; }
    .progress-list li.progress-success { color: #256029; }
    .progress-list li.progress-success::before { color: #27ae60; }
    .progress-list li.progress-failure { color: #c0392b; }
    .progress-list li.progress-failure::before { color: #c0392b; }
  </style>
  <script src="auth.js"></script>
</head>
<body>
<h1>Configuration MiniLabBox</h1>

<p class="hint">
  Les réglages du multimètre virtuel et des autres instruments sont désormais disponibles sur la page
  <a href="virtual-lab/settings.html">Réglages Virtual Lab</a>.
</p>

<p class="hint">
  Les paramètres Wi-Fi et l'identifiant du nœud ont été déplacés vers la page dédiée
  <a href="interface.html">Interface réseau</a>.
</p>

<form id="configForm" onsubmit="return false;">
  <fieldset>
    <legend>Modules optionnels</legend>
    <label><input type="checkbox" id="modAdc" checked disabled> ADC interne ESP (A0)</label><br>
    <label><input type="checkbox" id="modAds"> ADC externe ADS1115</label><br>
    <label><input type="checkbox" id="modPwm"> Convertisseur PWM → 0–10 V</label><br>
    <label><input type="checkbox" id="modDac"> DAC I²C MCP4725</label><br>
    <label><input type="checkbox" id="modZmpt"> Capteur de tension AC (ZMPT101B)</label><br>
    <label><input type="checkbox" id="modZmct"> Capteur de courant AC (ZMCT103C)</label><br>
    <label><input type="checkbox" id="modDiv"> Pont diviseur DC</label>
  </fieldset>

  <fieldset>
    <legend>Entrées</legend>
    <p class="hint">Ajoutez les mesures utiles et associez chaque entrée à son capteur ou à une valeur distante.</p>
    <div class="io-header">
      <button type="button" id="addInputBtn">Ajouter une entrée</button>
      <span class="counter" id="inputsCounter">0 / 4</span>
    </div>
    <div id="inputsList" class="io-list"></div>
  </fieldset>

  <fieldset>
    <legend>Sorties</legend>
    <p class="hint">Chaque sortie peut piloter un convertisseur PWM → 0–10 V, un simple GPIO ou le nouveau DAC I²C MCP4725.</p>
    <div class="io-header">
      <button type="button" id="addOutputBtn">Ajouter une sortie</button>
      <span class="counter" id="outputsCounter">0 / 2</span>
    </div>
    <div id="outputsList" class="io-list"></div>
  </fieldset>

  <fieldset>
    <legend>Firmware</legend>
    Version actuelle : <span id="fwVersion">?</span><br><br>
    <input type="file" id="fwFile">
    <button type="button" id="fwUploadBtn">Mettre à jour</button>
    <button type="button" id="fwRebootBtn">Redémarrer</button>
    <span id="fwStatus" style="margin-left:1em;"></span>
  </fieldset>

  <div class="form-actions">
    <button type="button" id="saveBtn" class="primary">Sauvegarder sans redémarrage</button>
    <button type="button" id="rebootBtn" class="secondary">Redémarrer</button>
    <span id="status" style="margin-left:1em;"></span>
  </div>
</form>

<div id="ioModal" class="modal hidden" role="dialog" aria-modal="true">
  <div class="modal-content">
    <h2 id="modalTitle">Configurer</h2>
    <p class="modal-description" id="modalDescription"></p>
    <div class="modal-info" id="modalInfo" aria-live="polite"></div>
    <form id="modalForm">
      <div class="modal-form-row">
        <label for="modalName">Nom</label>
        <input type="text" id="modalName" required>
      </div>
      <div class="modal-form-row">
        <label for="modalType">Type</label>
        <select id="modalType"></select>
      </div>
      <div class="modal-form-row" id="modalActiveRow">
        <label class="toggle"><input type="checkbox" id="modalActive"> Activer cette voie</label>
      </div>
      <div id="modalTypeFields"></div>
      <div class="modal-actions">
        <button type="button" class="secondary" id="modalCancel">Annuler</button>
        <button type="submit">Enregistrer</button>
      </div>
    </form>
  </div>
</div>

<div id="saveProgressModal" class="modal hidden" role="dialog" aria-modal="true">
  <div class="modal-content">
    <h2>Suivi de la sauvegarde</h2>
    <ul id="saveProgressList" class="progress-list"></ul>
    <div class="modal-actions">
      <button type="button" class="secondary" id="saveProgressClose">Fermer</button>
    </div>
  </div>
</div>

<script>
const MAX_INPUTS = 4;
const MAX_OUTPUTS = 2;
const ANALOG_PINS = ['A0'];
const DIGITAL_PINS = ['D0','D1','D2','D3','D4','D5','D6','D7','D8'];
const ANALOG_TYPES = new Set(['adc','div','zmpt','zmct']);
const OUTPUT_PIN_TYPES = new Set(['pwm010','gpio']);
const INPUT_TYPES = [
  { value: 'adc', label: 'ADC interne (A0)' },
  { value: 'ads1115', label: 'ADC externe ADS1115' },
  { value: 'remote', label: 'Valeur distante' },
  { value: 'zmpt', label: 'Capteur tension AC (ZMPT)' },
  { value: 'zmct', label: 'Capteur courant AC (ZMCT)' },
  { value: 'div', label: 'Diviseur DC' },
  { value: 'disabled', label: 'Désactivée' }
];
const OUTPUT_TYPES = [
  { value: 'pwm010', label: 'PWM → 0–10 V' },
  { value: 'gpio', label: 'Sortie GPIO' },
  { value: 'mcp4725', label: 'DAC I²C MCP4725' },
  { value: 'disabled', label: 'Désactivée' }
];
const MODULE_DEPENDENCIES = {
  input: {
    ads1115: 'ads1115',
    zmpt: 'zmpt',
    zmct: 'zmct',
    div: 'div'
  },
  output: {
    pwm010: 'pwm010',
    mcp4725: 'mcp4725'
  }
};

const INPUT_TYPE_DETAILS = {
  adc: {
    title: 'Entrée ADC interne',
    summary: 'Utilise le convertisseur analogique-numérique intégré de l’ESP8266 sur la broche A0.',
    resolution: '10 bits (0 à 1023 codes bruts).',
    rawRange: '0 à 1023 bits mesurés.',
    physicalRange: '≈ 0 à 1,0 V sur A0 (atténuation intégrée).',
    rawTagSuffix: '_bits',
    notes: [
      'La valeur publiée correspond directement au code brut de l’ADC (0 à 1023).'
    ]
  },
  ads1115: {
    title: 'Entrée ADS1115',
    summary: 'Lit un canal simple du convertisseur ADS1115 externe configuré en gain ×1.',
    resolution: '16 bits (0 à 32767 en mode simple).',
    rawRange: '0 à 32767 codes.',
    physicalRange: '0 à 4,096 V pour le gain par défaut.',
    rawTagSuffix: '_bits',
    notes: [
      'Chaque code représente environ 125 µV avec le gain ×1.',
      'Assurez-vous d’avoir activé le module ADS1115 dans la configuration.'
    ]
  },
  remote: {
    title: 'Entrée distante',
    summary: 'Récupère une mesure diffusée par un autre MiniLabBox via UDP sécurisé.',
    notes: [
      'La plage dépend du capteur distant ; aucune conversion matérielle locale n’est appliquée.',
      'Saisissez exactement l’identifiant du nœud et le nom distant pour recevoir la valeur.'
    ]
  },
  zmpt: {
    title: 'Capteur de tension AC (ZMPT101B)',
    summary: 'Calcule la valeur RMS de la composante AC mesurée par le module ZMPT101B.',
    resolution: '10 bits (calcul RMS sur 32 échantillons).',
    rawRange: '0 à ≈512 bits RMS autour de la valeur médiane.',
    physicalRange: 'Plage proportionnelle à la tension AC après calibration.',
    rawTagSuffix: '_bits',
    notes: [
      'La valeur brute correspond à l’écart autour de 512 (centre de l’ADC).',
      'Convertissez la valeur RMS en unités physiques dans vos scripts si nécessaire.'
    ]
  },
  zmct: {
    title: 'Capteur de courant AC (ZMCT103C)',
    summary: 'Mesure le courant AC RMS à l’aide du transformateur ZMCT103C et de l’ADC interne.',
    resolution: '10 bits (calcul RMS sur 32 échantillons).',
    rawRange: '0 à ≈512 bits RMS autour de la valeur médiane.',
    physicalRange: 'Plage proportionnelle au courant AC selon la calibration du capteur.',
    rawTagSuffix: '_bits',
    notes: [
      'Utilisez la sensibilité du capteur pour convertir les codes RMS en ampères.',
      'Un traitement logiciel supplémentaire peut compenser d’éventuels offsets.'
    ]
  },
  div: {
    title: 'Pont diviseur DC',
    summary: 'Mesure une tension continue via un pont diviseur raccordé à l’ADC interne.',
    resolution: '10 bits (0 à 1023 codes).',
    rawRange: '0 à 1023 bits bruts (moyenne de 32 échantillons).',
    physicalRange: '≈ 0 à 1,0 V en entrée A0 avant application du rapport du pont.',
    rawTagSuffix: '_bits',
    notes: [
      'Recalculez la tension réelle en appliquant le rapport du pont côté client.',
      'Un traitement logiciel permet de corriger un éventuel offset.'
    ]
  },
  disabled: {
    title: 'Entrée désactivée',
    summary: 'La voie n’est pas utilisée tant qu’un type actif n’est pas sélectionné.',
    notes: [
      'Activez la voie et choisissez un type pour commencer la mesure.'
    ]
  }
};

const OUTPUT_TYPE_DETAILS = {
  pwm010: {
    title: 'Sortie PWM → 0–10 V',
    summary: 'Pilote un convertisseur PWM/analogique pour générer une tension 0–10 V.',
    resolution: '10 bits (0 à 1023 de rapport cyclique).',
    rawRange: '0 à 1023 (pour le rapport cyclique PWM).',
    physicalRange: '≈ 0 à 10 V après conversion.',
    notes: [
      'La consigne attend une valeur comprise entre 0 et 1023 pour représenter le rapport cyclique.',
      'Ajustez la fréquence PWM en fonction des besoins de votre module 0–10 V.'
    ]
  },
  gpio: {
    title: 'Sortie GPIO',
    summary: 'Commande directe d’un GPIO numérique de l’ESP8266.',
    resolution: '1 bit (niveau logique bas ou haut).',
    physicalRange: '0 V (LOW) ou 3,3 V (HIGH) sur la broche sélectionnée.',
    notes: [
      'Toute consigne supérieure à 0,5 est interprétée comme HIGH.',
      'Utilisez ce mode pour piloter des relais ou des LEDs avec adaptation appropriée.'
    ]
  },
  mcp4725: {
    title: 'Sortie DAC MCP4725',
    summary: 'Génère une tension analogique via le DAC I²C MCP4725.',
    resolution: '12 bits (0 à 4095 codes).',
    rawRange: '0 à 4095 codes DAC.',
    physicalRange: '0 à VCC du module (souvent 5 V).',
    notes: [
      'La consigne doit être exprimée en codes DAC (0 à 4095).',
      'Vérifiez l’adresse I²C (0x60 ou 0x61) selon le cavalier matériel.'
    ]
  },
  disabled: {
    title: 'Sortie désactivée',
    summary: 'Aucun signal n’est généré tant que la voie reste désactivée.',
    notes: [
      'Activez la voie et choisissez un type pour la piloter.'
    ]
  }
};

function defaultIoName(kind, index) {
  const baseIndex = Number.isFinite(index) ? index : 0;
  return kind === 'input' ? `IN${baseIndex + 1}` : `OUT${baseIndex + 1}`;
}

function normaliseTagSlug(name) {
  if (!name) return '';
  const normalised = name.trim().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  const slug = normalised.replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
  return slug;
}

function getIoExplanation(kind, data, fallbackName, indexHint) {
  const dictionaries = kind === 'input' ? INPUT_TYPE_DETAILS : OUTPUT_TYPE_DETAILS;
  const typeKey = data.type && dictionaries[data.type] ? data.type : 'disabled';
  const base = dictionaries[typeKey] || dictionaries.disabled;
  let name = data.name && data.name.trim().length ? data.name.trim() : '';
  if (!name) {
    if (fallbackName) {
      name = fallbackName;
    } else {
      name = defaultIoName(kind, Number.isFinite(indexHint) ? indexHint : 0);
    }
  }
  const lines = [];
  if (name) {
    lines.push(`Tag JSON : ${name}`);
  }
  if (base.rawTagSuffix) {
    const slug = normaliseTagSlug(name);
    if (slug) {
      const rawLabel = `${slug}${base.rawTagSuffix}`;
      if (base.rawRange) {
        lines.push(`Tag brut suggéré : ${rawLabel} (${base.rawRange})`);
      } else {
        lines.push(`Tag brut suggéré : ${rawLabel}`);
      }
    }
  }
  if (base.resolution) {
    lines.push(`Résolution : ${base.resolution}`);
  }
  if (base.rawRange && !base.rawTagSuffix) {
    lines.push(`Valeur brute : ${base.rawRange}`);
  }
  if (base.physicalRange) {
    lines.push(`Plage physique : ${base.physicalRange}`);
  }
  if (Array.isArray(base.notes)) {
    base.notes.forEach(note => lines.push(note));
  }
  return {
    title: base.title,
    summary: base.summary,
    lines
  };
}

let inputs = [];
let outputs = [];
const moduleState = {
  adc: true,
  ads1115: false,
  pwm010: false,
  mcp4725: false,
  zmpt: false,
  zmct: false,
  div: false
};
let modalState = null;

const IO_LOG_SOURCE = 'io-config';
const IO_LOG_ENDPOINT = '/api/logs/append';
let ioLogSession = null;
const ioLogQueue = [];
let ioLogSending = false;

const STATUS_SYNCED = 'synced';
const STATUS_PENDING = 'pending';
let lastAppliedInputs = new Map();
let lastAppliedOutputs = new Map();
let saveInProgress = false;
let saveProgressModal = null;
let saveProgressList = null;
let saveProgressClose = null;
let rebootShouldBeEnabled = false;

function normaliseErrorForLog(err) {
  if (err instanceof Error) {
    return { message: err.message, stack: err.stack };
  }
  if (err && typeof err === 'object') {
    const out = {};
    if (typeof err.message === 'string' && err.message.length) {
      out.message = err.message;
    }
    if (typeof err.code === 'string' && err.code.length) {
      out.code = err.code;
    }
    if (typeof err.status === 'number') {
      out.status = err.status;
    }
    return Object.keys(out).length ? out : err;
  }
  if (err !== undefined && err !== null) {
    return { message: String(err) };
  }
  return { message: 'unknown error' };
}

function describeErrorMessage(err, fallback) {
  if (!err) return fallback;
  if (typeof err === 'string') {
    return err;
  }
  if (err instanceof Error && err.message) {
    return err.message;
  }
  if (typeof err.message === 'string' && err.message.length) {
    return err.message;
  }
  if (typeof err.status === 'number') {
    return `code ${err.status}`;
  }
  if (typeof err.code === 'string' && err.code.length) {
    return err.code;
  }
  return fallback;
}

function serialiseIoLogDetail(detail) {
  if (detail === undefined || detail === null) {
    return '';
  }
  if (typeof detail === 'string') {
    return detail;
  }
  try {
    return JSON.stringify(detail);
  } catch (err) {
    try {
      return String(detail);
    } catch (stringErr) {
      return '';
    }
  }
}

function escapeIoLogCsvField(value) {
  if (value === undefined || value === null) {
    return '';
  }
  const str = String(value);
  const escaped = str.replace(/"/g, '""');
  return /[",\n\r]/.test(escaped) ? `"${escaped}"` : escaped;
}

function buildIoLogCsv(entry) {
  const session = entry.session || {};
  const fields = [
    entry.timestamp !== undefined && entry.timestamp !== null ? entry.timestamp : '',
    entry.source || '',
    entry.event || '',
    session.kind || '',
    session.title || '',
    entry.step !== undefined && entry.step !== null ? entry.step : '',
    entry.message || '',
    entry.detail || ''
  ];
  return fields.map(escapeIoLogCsvField).join(',') + '\n';
}

function markRebootPrompt(active) {
  const rebootBtn = document.getElementById('rebootBtn');
  if (!rebootBtn) return;
  if (active) {
    rebootBtn.classList.add('attention');
  } else {
    rebootBtn.classList.remove('attention');
  }
}

function openSaveProgressModal() {
  if (!saveProgressModal) return;
  saveProgressModal.classList.remove('hidden');
  if (saveProgressList) {
    saveProgressList.innerHTML = '';
    saveProgressList.scrollTop = 0;
  }
  if (saveProgressClose) {
    saveProgressClose.disabled = true;
  }
}

function closeSaveProgressModal() {
  if (!saveProgressModal) return;
  saveProgressModal.classList.add('hidden');
}

function appendSaveProgressEvent(message, type = 'start', success = true) {
  if (!saveProgressList) return;
  const item = document.createElement('li');
  item.textContent = message;
  if (type === 'start') {
    item.classList.add('progress-start');
  } else if (success) {
    item.classList.add('progress-success');
  } else {
    item.classList.add('progress-failure');
  }
  saveProgressList.appendChild(item);
  saveProgressList.scrollTop = saveProgressList.scrollHeight;
}

function allowSaveProgressClose() {
  if (saveProgressClose) {
    saveProgressClose.disabled = false;
  }
}

function recordIoLogEvent(event, message, detail, { stepIncrement = false, force = false } = {}) {
  const session = ioLogSession;
  const shouldLog = force || (session && session.kind === 'save');
  if (!shouldLog) {
    if (session && stepIncrement) {
      if (typeof session.step !== 'number') {
        session.step = 0;
      }
      session.step += 1;
    }
    return;
  }
  const payload = {
    source: IO_LOG_SOURCE,
    event,
    message: message || '',
    timestamp: Date.now()
  };
  if (detail !== undefined) {
    payload.detail = serialiseIoLogDetail(detail);
  }
  if (session) {
    if (typeof session.step !== 'number') {
      session.step = 0;
    }
    if (stepIncrement) {
      session.step += 1;
    }
    payload.session = {
      kind: session.kind,
      title: session.title
    };
    payload.step = session.step;
  }
  ioLogQueue.push(payload);
  triggerIoLogFlush();
}

function triggerIoLogFlush() {
  if (ioLogSending || ioLogQueue.length === 0) {
    return;
  }
  ioLogSending = true;
  (async () => {
    try {
      while (ioLogQueue.length) {
        const entry = ioLogQueue.shift();
        try {
          const csvBody = buildIoLogCsv(entry);
          await authFetch(IO_LOG_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'text/csv' },
            body: csvBody
          });
        } catch (err) {
          console.warn('Impossible d\'envoyer un événement de configuration', err);
        }
      }
    } finally {
      ioLogSending = false;
      if (ioLogQueue.length) {
        triggerIoLogFlush();
      }
    }
  })();
}

function startIoLogSession(kind, options = {}) {
  const defaultTitle = kind === 'input'
    ? 'Ajout d’une entrée'
    : kind === 'output'
      ? 'Ajout d’une sortie'
      : 'Suivi de la configuration';
  const title = options.title || defaultTitle;
  const mode = options.mode || (kind === 'save' ? 'save' : 'add');
  ioLogSession = { kind, title, mode, step: 0 };
  console.log(`[IO] ${title} démarrée`);
  recordIoLogEvent('start', `${title} démarrée`, undefined, {
    force: kind === 'save'
  });
}

function logIoStep(message, detail) {
  if (detail !== undefined) {
    console.log(`[IO] ${message}`, detail);
  } else {
    console.log(`[IO] ${message}`);
  }
  recordIoLogEvent('step', message, detail, { stepIncrement: true });
}

function completeIoLogSession(finalMessage) {
  if (!ioLogSession) return;
  const sessionTitle = ioLogSession.title || 'Séquence';
  const isSave = ioLogSession.kind === 'save';
  recordIoLogEvent('complete', finalMessage || 'Séquence terminée', undefined, {
    stepIncrement: true,
    force: isSave
  });
  recordIoLogEvent('end', `${sessionTitle} terminée`, undefined, { force: isSave });
  ioLogSession = null;
}

function cancelIoLogSession(reason) {
  if (!ioLogSession) return;
  const sessionTitle = ioLogSession.title || 'Séquence';
  const isSave = ioLogSession.kind === 'save';
  recordIoLogEvent('cancel', reason || 'Séquence interrompue', undefined, {
    stepIncrement: true,
    force: isSave
  });
  recordIoLogEvent('end', `${sessionTitle} interrompue`, undefined, { force: isSave });
  ioLogSession = null;
}

function getSnapshotMap(kind) {
  return kind === 'input' ? lastAppliedInputs : lastAppliedOutputs;
}

function refreshModuleStateFromForm() {
  const modAdc = document.getElementById('modAdc');
  const modAds = document.getElementById('modAds');
  const modPwm = document.getElementById('modPwm');
  const modDac = document.getElementById('modDac');
  const modZmpt = document.getElementById('modZmpt');
  const modZmct = document.getElementById('modZmct');
  const modDiv = document.getElementById('modDiv');
  moduleState.adc = modAdc ? !!modAdc.checked : true;
  moduleState.ads1115 = !!(modAds && modAds.checked);
  moduleState.pwm010 = !!(modPwm && modPwm.checked);
  moduleState.mcp4725 = !!(modDac && modDac.checked);
  moduleState.zmpt = !!(modZmpt && modZmpt.checked);
  moduleState.zmct = !!(modZmct && modZmct.checked);
  moduleState.div = !!(modDiv && modDiv.checked);
}

function isTypeAvailable(kind, type) {
  if (type === 'disabled') {
    return true;
  }
  if (kind === 'input') {
    if (type === 'adc' || type === 'remote') {
      return true;
    }
    const moduleKey = MODULE_DEPENDENCIES.input[type];
    if (!moduleKey) {
      return true;
    }
    return !!moduleState[moduleKey];
  }
  if (type === 'gpio') {
    return true;
  }
  const moduleKey = MODULE_DEPENDENCIES.output[type];
  if (!moduleKey) {
    return true;
  }
  return !!moduleState[moduleKey];
}

function typeOptionsForKind(kind) {
  const source = kind === 'input' ? INPUT_TYPES : OUTPUT_TYPES;
  return source.filter(opt => isTypeAvailable(kind, opt.value));
}

function firstAvailableType(kind) {
  const options = typeOptionsForKind(kind);
  if (options.length > 0) {
    return options[0].value;
  }
  return 'disabled';
}

function gatherUsedPins(kind, typeSet, excludeIndex) {
  const used = new Set();
  const list = kind === 'input' ? inputs : outputs;
  list.forEach((item, idx) => {
    if (!item || idx === excludeIndex) {
      return;
    }
    if (!item.active || !item.pin) {
      return;
    }
    if (typeSet.has(item.type)) {
      used.add(item.pin);
    }
  });
  return used;
}

function availablePinsForInput(data, index) {
  if (!ANALOG_TYPES.has(data.type)) {
    return [];
  }
  const basePins = Array.from(new Set([...ANALOG_PINS]));
  const used = gatherUsedPins('input', ANALOG_TYPES, index);
  return basePins.filter(pin => !used.has(pin) || data.pin === pin);
}

function availablePinsForOutput(data, index) {
  if (!OUTPUT_PIN_TYPES.has(data.type)) {
    return [];
  }
  const used = gatherUsedPins('output', OUTPUT_PIN_TYPES, index);
  return DIGITAL_PINS.filter(pin => !used.has(pin) || data.pin === pin);
}

function ensureTypeAvailability(kind) {
  const source = kind === 'input' ? inputs : outputs;
  let changed = false;
  source.forEach((item, idx) => {
    if (!item) return;
    if (isTypeAvailable(kind, item.type)) {
      return;
    }
    const previousName = item.name;
    logIoStep(`Type ${item.type} indisponible pour ${kind === 'input' ? 'entrée' : 'sortie'} ${previousName || (kind === 'input' ? `IN${idx + 1}` : `OUT${idx + 1}`)} — passage en mode désactivé.`);
    const replacement = kind === 'input' ? newInputConfig('disabled') : newOutputConfig('disabled');
    replacement.name = previousName;
    replacement.active = false;
    source[idx] = replacement;
    const snapshot = kind === 'input' ? snapshotInput(replacement, idx) : snapshotOutput(replacement, idx);
    recordPendingSnapshot(kind, snapshot, previousName && previousName !== snapshot.name ? previousName : undefined);
    changed = true;
  });
  return changed;
}

function handleModuleStateChange() {
  refreshModuleStateFromForm();
  markRebootPrompt(false);
  logIoStep('Mise à jour des modules optionnels', {
    adc: moduleState.adc,
    ads1115: moduleState.ads1115,
    pwm010: moduleState.pwm010,
    mcp4725: moduleState.mcp4725,
    zmpt: moduleState.zmpt,
    zmct: moduleState.zmct,
    div: moduleState.div
  });
  const inputsChanged = ensureTypeAvailability('input');
  const outputsChanged = ensureTypeAvailability('output');
  if (inputsChanged || outputsChanged) {
    logIoStep('Certaines voies ont été désactivées suite au changement de modules.');
  }
  renderIoList('input');
  renderIoList('output');
  if (modalState) {
    applyTypeChange(modalState.kind, modalState.data.type);
    renderModalForm();
  }
}

function snapshotInput(item, idx) {
  const name = item.name && item.name.trim().length ? item.name.trim() : `IN${idx + 1}`;
  const snapshot = {
    name,
    type: item.type || 'disabled',
    active: !!item.active
  };
  if (['adc', 'div', 'zmpt', 'zmct'].includes(snapshot.type)) {
    snapshot.pin = item.pin || '';
  }
  if (snapshot.type === 'ads1115') {
    snapshot.adsChannel = toInteger(item.adsChannel, 0, { min: 0, max: 3 });
  }
  if (snapshot.type === 'remote') {
    snapshot.remoteNode = item.remoteNode || '';
    snapshot.remoteName = item.remoteName || '';
  }
  return snapshot;
}

function snapshotOutput(item, idx) {
  const name = item.name && item.name.trim().length ? item.name.trim() : `OUT${idx + 1}`;
  const snapshot = {
    name,
    type: item.type || 'disabled',
    active: !!item.active
  };
  if (['pwm010', 'gpio'].includes(snapshot.type)) {
    snapshot.pin = item.pin || '';
  }
  if (snapshot.type === 'pwm010') {
    snapshot.pwmFreq = toInteger(item.pwmFreq, 2000, { min: 1 });
  }
  if (snapshot.type === 'mcp4725') {
    snapshot.i2cAddress = item.i2cAddress && item.i2cAddress.length ? item.i2cAddress : '0x60';
  }
  return snapshot;
}

function snapshotSignature(snapshot) {
  return JSON.stringify(snapshot);
}

function recordSyncedSnapshot(kind, snapshot) {
  const map = getSnapshotMap(kind);
  const signature = snapshotSignature(snapshot);
  map.set(snapshot.name, { state: STATUS_SYNCED, signature, saved: signature });
}

function recordPendingSnapshot(kind, snapshot, previousKey) {
  const map = getSnapshotMap(kind);
  let savedSignature = null;
  if (previousKey && previousKey !== snapshot.name) {
    const previousEntry = map.get(previousKey);
    if (previousEntry && typeof previousEntry.saved === 'string') {
      savedSignature = previousEntry.saved;
    }
    map.delete(previousKey);
  }
  const signature = snapshotSignature(snapshot);
  const existing = map.get(snapshot.name);
  if (existing) {
    if (existing.state === STATUS_SYNCED && existing.signature === signature) {
      map.set(snapshot.name, { state: STATUS_SYNCED, signature, saved: existing.saved || signature });
      return;
    }
    if (typeof existing.saved === 'string') {
      savedSignature = existing.saved;
    }
  }
  if (savedSignature !== null && savedSignature === signature) {
    map.set(snapshot.name, { state: STATUS_SYNCED, signature, saved: signature });
  } else {
    map.set(snapshot.name, { state: STATUS_PENDING, signature, saved: savedSignature });
  }
  markRebootPrompt(false);
}

function removeSnapshot(kind, key) {
  const map = getSnapshotMap(kind);
  map.delete(key);
  markRebootPrompt(false);
}

function resetSnapshotsFromConfig(kind, list) {
  const map = getSnapshotMap(kind);
  map.clear();
  list.forEach((item, idx) => {
    const snapshot = kind === 'input' ? snapshotInput(item, idx) : snapshotOutput(item, idx);
    recordSyncedSnapshot(kind, snapshot);
  });
}

function markAllSnapshotsSaved() {
  resetSnapshotsFromConfig('input', inputs);
  resetSnapshotsFromConfig('output', outputs);
}

function applyServerSnapshots(kind, entries) {
  const map = getSnapshotMap(kind);
  map.clear();
  if (!Array.isArray(entries)) return;
  entries.forEach(entry => {
    if (!entry || !entry.name) return;
    const signature = JSON.stringify(entry);
    map.set(entry.name, { state: STATUS_SYNCED, signature, saved: signature });
  });
}

function statusForSnapshot(kind, item, idx) {
  const snapshot = kind === 'input' ? snapshotInput(item, idx) : snapshotOutput(item, idx);
  const map = getSnapshotMap(kind);
  const entry = map.get(snapshot.name);
  const signature = snapshotSignature(snapshot);
  if (entry) {
    if (typeof entry.saved === 'string' && entry.saved === signature) {
      if (entry.state !== STATUS_SYNCED || entry.signature !== signature) {
        recordSyncedSnapshot(kind, snapshot);
      }
      return { className: 'synced', text: 'Synchronisé' };
    }
    if (entry.state === STATUS_PENDING) {
      return { className: 'pending', text: 'À enregistrer' };
    }
    if (entry.state === STATUS_SYNCED) {
      return { className: 'synced', text: 'Synchronisé' };
    }
  }
  return { className: 'pending', text: 'À enregistrer' };
}

function toNumber(value, fallback) {
  if (value === null || value === undefined) {
    return fallback;
  }
  if (typeof value === 'string') {
    const trimmed = value.trim();
    if (trimmed.length === 0) {
      return fallback;
    }
    value = trimmed;
  }
  const num = Number(value);
  return Number.isFinite(num) ? num : fallback;
}

function toInteger(value, fallback, options = {}) {
  const num = toNumber(value, fallback);
  if (!Number.isFinite(num)) {
    return fallback;
  }
  let result = Math.round(num);
  if (options.min !== undefined) {
    result = Math.max(options.min, result);
  }
  if (options.max !== undefined) {
    result = Math.min(options.max, result);
  }
  return result;
}

function newInputConfig(type) {
  const resolvedType = isTypeAvailable('input', type) ? type : firstAvailableType('input');
  const cfg = {
    name: '',
    type: resolvedType,
    active: true,
    pin: '',
    adsChannel: 0,
    remoteNode: '',
    remoteName: ''
  };
  if (ANALOG_TYPES.has(cfg.type)) {
    cfg.pin = 'A0';
  }
  if (cfg.type === 'ads1115') {
    cfg.adsChannel = 0;
  }
  if (cfg.type === 'disabled') {
    cfg.active = false;
  }
  return cfg;
}

function newOutputConfig(type) {
  const resolvedType = isTypeAvailable('output', type) ? type : firstAvailableType('output');
  const cfg = {
    name: '',
    type: resolvedType,
    active: true,
    pin: '',
    pwmFreq: 2000,
    i2cAddress: '0x60'
  };
  if (cfg.type === 'pwm010') {
    cfg.pin = 'D2';
    cfg.pwmFreq = 2000;
  } else if (cfg.type === 'gpio') {
    cfg.pin = 'D1';
  } else if (cfg.type === 'disabled') {
    cfg.active = false;
  }
  return cfg;
}

function cloneConfig(obj) {
  return JSON.parse(JSON.stringify(obj));
}

function typeLabel(kind, value) {
  const source = kind === 'input' ? INPUT_TYPES : OUTPUT_TYPES;
  const found = source.find(o => o.value === value);
  return found ? found.label : value;
}

function normaliseInput(data) {
  const requestedType = data.type || 'disabled';
  const availableType = isTypeAvailable('input', requestedType) ? requestedType : firstAvailableType('input');
  if (requestedType !== availableType) {
    logIoStep(`Type ${requestedType} indisponible à l'import, utilisation de ${availableType}.`);
  }
  const base = newInputConfig(availableType);
  base.name = data.name || '';
  base.active = !!data.active;
  base.pin = data.pin || base.pin;
  const channel = parseInt(data.adsChannel, 10);
  base.adsChannel = Number.isFinite(channel) ? channel : base.adsChannel;
  base.remoteNode = data.remoteNode || '';
  base.remoteName = data.remoteName || '';
  return base;
}

function normaliseOutput(data) {
  const requestedType = data.type || 'disabled';
  const availableType = isTypeAvailable('output', requestedType) ? requestedType : firstAvailableType('output');
  if (requestedType !== availableType) {
    logIoStep(`Type ${requestedType} indisponible à l'import pour une sortie, utilisation de ${availableType}.`);
  }
  const base = newOutputConfig(availableType);
  base.name = data.name || '';
  base.active = !!data.active;
  base.pin = data.pin || base.pin;
  base.pwmFreq = Math.max(1, Math.round(toNumber(data.pwmFreq, base.pwmFreq)));
  base.i2cAddress = data.i2cAddress || base.i2cAddress;
  return base;
}

function updateIoCounters() {
  const inCounter = document.getElementById('inputsCounter');
  if (inCounter) inCounter.textContent = `${inputs.length} / ${MAX_INPUTS}`;
  const outCounter = document.getElementById('outputsCounter');
  if (outCounter) outCounter.textContent = `${outputs.length} / ${MAX_OUTPUTS}`;
}

function describeInput(item, index) {
  const fallbackName = item && item.name && item.name.trim()
    ? item.name.trim()
    : `IN${(index != null ? index : 0) + 1}`;
  const explanation = getIoExplanation('input', item || {}, fallbackName, index);
  const details = explanation.lines.slice();
  if (item && ['adc','div','zmpt','zmct'].includes(item.type) && item.pin) {
    details.push(`Broche utilisée : ${item.pin}`);
  }
  if (item && item.type === 'ads1115') {
    details.push(`Canal ADS1115 : A${item.adsChannel}`);
  }
  if (item && item.type === 'remote') {
    if (item.remoteNode) details.push(`Nœud distant : ${item.remoteNode}`);
    if (item.remoteName) details.push(`Nom distant : ${item.remoteName}`);
  }
  return details;
}

function describeOutput(item, index) {
  const fallbackName = item && item.name && item.name.trim()
    ? item.name.trim()
    : `OUT${(index != null ? index : 0) + 1}`;
  const explanation = getIoExplanation('output', item || {}, fallbackName, index);
  const details = explanation.lines.slice();
  if (item && (item.type === 'pwm010' || item.type === 'gpio') && item.pin) {
    details.push(`Broche utilisée : ${item.pin}`);
  }
  if (item && item.type === 'pwm010') {
    details.push(`Fréquence PWM : ${item.pwmFreq} Hz`);
  }
  if (item && item.type === 'mcp4725') {
    details.push(`Adresse I²C : ${item.i2cAddress}`);
  }
  return details;
}

function renderIoList(kind) {
  const listEl = document.getElementById(kind === 'input' ? 'inputsList' : 'outputsList');
  if (!listEl) return;
  const source = kind === 'input' ? inputs : outputs;
  listEl.innerHTML = '';
  if (!source.length) {
    const empty = document.createElement('div');
    empty.className = 'io-empty';
    empty.textContent = kind === 'input' ? 'Aucune entrée configurée.' : 'Aucune sortie configurée.';
    listEl.appendChild(empty);
    updateIoCounters();
    return;
  }
  source.forEach((item, idx) => {
    const card = document.createElement('div');
    card.className = 'io-card';
    const header = document.createElement('div');
    header.className = 'io-card-header';
    const title = document.createElement('h3');
    title.textContent = item.name || (kind === 'input' ? `Entrée ${idx + 1}` : `Sortie ${idx + 1}`);
    header.appendChild(title);
    const controls = document.createElement('div');
    const typeLabelEl = document.createElement('div');
    typeLabelEl.className = 'io-type';
    typeLabelEl.textContent = typeLabel(kind, item.type);
    controls.appendChild(typeLabelEl);
    const toggleLabel = document.createElement('label');
    toggleLabel.className = 'toggle';
    const toggle = document.createElement('input');
    toggle.type = 'checkbox';
    toggle.checked = !!item.active;
    toggle.addEventListener('change', () => {
      item.active = toggle.checked;
      const snapshot = kind === 'input' ? snapshotInput(item, idx) : snapshotOutput(item, idx);
      const signature = snapshotSignature(snapshot);
      const map = getSnapshotMap(kind);
      const entry = map.get(snapshot.name);
      if (entry && entry.state === STATUS_SYNCED && entry.signature === signature) {
        recordSyncedSnapshot(kind, snapshot);
      } else {
        recordPendingSnapshot(kind, snapshot);
      }
      renderIoList(kind);
    });
    toggleLabel.appendChild(toggle);
    toggleLabel.appendChild(document.createTextNode(' Actif'));
    controls.appendChild(toggleLabel);
    const statusInfo = statusForSnapshot(kind, item, idx);
    const statusEl = document.createElement('span');
    statusEl.className = `io-status ${statusInfo.className}`;
    statusEl.textContent = statusInfo.text;
    controls.appendChild(statusEl);
    header.appendChild(controls);
    card.appendChild(header);
    const detailList = document.createElement('ul');
    detailList.className = 'io-details';
    const lines = kind === 'input' ? describeInput(item, idx) : describeOutput(item, idx);
    lines.forEach(text => {
      const li = document.createElement('li');
      li.textContent = text;
      detailList.appendChild(li);
    });
    card.appendChild(detailList);
    const actions = document.createElement('div');
    actions.className = 'io-actions';
    const editBtn = document.createElement('button');
    editBtn.type = 'button';
    editBtn.className = 'secondary';
    editBtn.textContent = 'Modifier';
    editBtn.addEventListener('click', () => openIoModal(kind, idx));
    actions.appendChild(editBtn);
    const delBtn = document.createElement('button');
    delBtn.type = 'button';
    delBtn.className = 'danger';
    delBtn.textContent = 'Supprimer';
    delBtn.addEventListener('click', () => {
      if (confirm('Supprimer cette configuration ?')) {
        if (kind === 'input') {
          const removed = inputs.splice(idx, 1)[0];
          if (removed) {
            const snap = snapshotInput(removed, idx);
            removeSnapshot('input', snap.name);
          }
          renderIoList('input');
        } else {
          const removed = outputs.splice(idx, 1)[0];
          if (removed) {
            const snap = snapshotOutput(removed, idx);
            removeSnapshot('output', snap.name);
          }
          renderIoList('output');
        }
      }
    });
    actions.appendChild(delBtn);
    card.appendChild(actions);
    listEl.appendChild(card);
  });
  updateIoCounters();
}

function openIoModal(kind, index) {
  const modal = document.getElementById('ioModal');
  if (!modal) return;
  let data;
  if (index != null) {
    const source = kind === 'input' ? inputs : outputs;
    data = cloneConfig(source[index]);
  } else {
    const defaults = kind === 'input' ? newInputConfig(firstAvailableType('input')) : newOutputConfig(firstAvailableType('output'));
    defaults.name = kind === 'input' ? `IN${inputs.length + 1}` : `OUT${outputs.length + 1}`;
    data = defaults;
  }
  modalState = { kind, index, data };
  logIoStep(`Ouverture du formulaire ${kind === 'input' ? 'entrée' : 'sortie'}`, { index, type: data.type });
  renderModalForm();
  modal.classList.remove('hidden');
}

function closeIoModal(cancelled = false) {
  const modal = document.getElementById('ioModal');
  if (modal) {
    modal.classList.add('hidden');
  }
  if (cancelled && ioLogSession && ioLogSession.mode === 'add') {
    cancelIoLogSession('Ajout annulé');
  }
  modalState = null;
}

function applyTypeChange(kind, newType) {
  if (!modalState) return;
  const old = modalState.data;
  if (!isTypeAvailable(kind, newType)) {
    logIoStep(`Type ${newType} indisponible pour ${kind}, sélection automatique ignorée.`);
    newType = firstAvailableType(kind);
  }
  if (old.type === newType) return;
  const defaults = kind === 'input' ? newInputConfig(newType) : newOutputConfig(newType);
  defaults.name = old.name;
  defaults.active = old.active;
  logIoStep(`Changement de type ${kind === 'input' ? 'entrée' : 'sortie'}: ${old.type} → ${newType}`);
  modalState.data = defaults;
}

function renderTypeSpecificFields(data, kind) {
  const container = document.getElementById('modalTypeFields');
  if (!container) return;
  container.innerHTML = '';
  if (kind === 'input') {
    if (ANALOG_TYPES.has(data.type)) {
      const row = document.createElement('div');
      row.className = 'modal-form-row';
      const label = document.createElement('label');
      label.textContent = 'PIN';
      const select = document.createElement('select');
      const availablePins = availablePinsForInput(data, modalState ? modalState.index : -1);
      if (!data.pin || !availablePins.includes(data.pin)) {
        data.pin = availablePins.length ? availablePins[0] : '';
      }
      if (availablePins.length === 0) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = 'Aucune broche disponible';
        select.appendChild(opt);
        select.disabled = true;
        logIoStep('Aucune broche analogique disponible pour la nouvelle entrée.');
      } else {
        availablePins.forEach(pin => {
          const opt = document.createElement('option');
          opt.value = pin;
          opt.textContent = pin;
          select.appendChild(opt);
        });
        select.value = data.pin;
      }
      select.onchange = (ev) => {
        modalState.data.pin = ev.target.value;
      };
      row.appendChild(label);
      row.appendChild(select);
      container.appendChild(row);
    } else if (data.type === 'ads1115') {
      const row = document.createElement('div');
      row.className = 'modal-form-row';
      const label = document.createElement('label');
      label.textContent = 'Canal ADS1115';
      const select = document.createElement('select');
      [0,1,2,3].forEach(ch => {
        const opt = document.createElement('option');
        opt.value = ch;
        opt.textContent = `A${ch}`;
        select.appendChild(opt);
      });
      const selectedChannel = toInteger(data.adsChannel, 0, { min: 0, max: 3 });
      select.value = String(selectedChannel);
      modalState.data.adsChannel = selectedChannel;
      select.onchange = (ev) => {
        modalState.data.adsChannel = toInteger(ev.target.value, 0, { min: 0, max: 3 });
      };
      row.appendChild(label);
      row.appendChild(select);
      container.appendChild(row);
    } else if (data.type === 'remote') {
      const rowNode = document.createElement('div');
      rowNode.className = 'modal-form-row';
      const labelNode = document.createElement('label');
      labelNode.textContent = 'Nœud distant';
      const inputNode = document.createElement('input');
      inputNode.type = 'text';
      inputNode.value = data.remoteNode || '';
      inputNode.oninput = (ev) => {
        modalState.data.remoteNode = ev.target.value.trim();
      };
      rowNode.appendChild(labelNode);
      rowNode.appendChild(inputNode);
      container.appendChild(rowNode);
      const rowName = document.createElement('div');
      rowName.className = 'modal-form-row';
      const labelName = document.createElement('label');
      labelName.textContent = "Nom de l'entrée distante";
      const inputName = document.createElement('input');
      inputName.type = 'text';
      inputName.value = data.remoteName || '';
      inputName.oninput = (ev) => {
        modalState.data.remoteName = ev.target.value.trim();
      };
      rowName.appendChild(labelName);
      rowName.appendChild(inputName);
      container.appendChild(rowName);
    }
  } else {
    if (OUTPUT_PIN_TYPES.has(data.type)) {
      const row = document.createElement('div');
      row.className = 'modal-form-row';
      const label = document.createElement('label');
      label.textContent = 'Pin de sortie';
      const select = document.createElement('select');
      const availablePins = availablePinsForOutput(data, modalState ? modalState.index : -1);
      if (!data.pin || !availablePins.includes(data.pin)) {
        data.pin = availablePins.length ? availablePins[0] : '';
      }
      if (availablePins.length === 0) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = 'Aucune broche disponible';
        select.appendChild(opt);
        select.disabled = true;
        logIoStep('Aucune broche numérique libre pour la sortie demandée.');
      } else {
        availablePins.forEach(pin => {
          const opt = document.createElement('option');
          opt.value = pin;
          opt.textContent = pin;
          select.appendChild(opt);
        });
        select.value = data.pin;
      }
      select.onchange = (ev) => {
        modalState.data.pin = ev.target.value;
      };
      row.appendChild(label);
      row.appendChild(select);
      container.appendChild(row);
    }
    if (data.type === 'pwm010') {
      const row = document.createElement('div');
      row.className = 'modal-form-row';
      const label = document.createElement('label');
      label.textContent = 'Fréquence PWM (Hz)';
      const input = document.createElement('input');
      input.type = 'number';
      input.min = '1';
      input.max = '40000';
      input.value = data.pwmFreq || 2000;
      input.oninput = (ev) => {
        modalState.data.pwmFreq = toInteger(ev.target.value, 2000, { min: 1 });
      };
      row.appendChild(label);
      row.appendChild(input);
      container.appendChild(row);
    }
    if (data.type === 'mcp4725') {
      const row = document.createElement('div');
      row.className = 'modal-form-row';
      const label = document.createElement('label');
      label.textContent = 'Adresse I²C (ex. 0x60)';
      const input = document.createElement('input');
      input.type = 'text';
      input.value = data.i2cAddress || '0x60';
      input.oninput = (ev) => {
        modalState.data.i2cAddress = ev.target.value.trim();
      };
      row.appendChild(label);
      row.appendChild(input);
      container.appendChild(row);
    }
  }
}

function renderModalInfoPanel(kind, data, indexHint) {
  const panel = document.getElementById('modalInfo');
  if (!panel) return;
  const effectiveIndex = indexHint != null ? indexHint : (kind === 'input' ? inputs.length : outputs.length);
  const fallback = data && data.name && data.name.trim().length
    ? data.name.trim()
    : defaultIoName(kind, effectiveIndex);
  const info = getIoExplanation(kind, data || {}, fallback, effectiveIndex);
  panel.innerHTML = '';
  const titleEl = document.createElement('h3');
  titleEl.textContent = info.title;
  panel.appendChild(titleEl);
  const summaryEl = document.createElement('p');
  summaryEl.textContent = info.summary;
  panel.appendChild(summaryEl);
  const listEl = document.createElement('ul');
  info.lines.forEach(text => {
    const li = document.createElement('li');
    li.textContent = text;
    listEl.appendChild(li);
  });
  panel.appendChild(listEl);
}

function renderModalForm() {
  if (!modalState) return;
  const { kind, index, data } = modalState;
  const title = document.getElementById('modalTitle');
  const description = document.getElementById('modalDescription');
  const nameInput = document.getElementById('modalName');
  const typeSelect = document.getElementById('modalType');
  const activeRow = document.getElementById('modalActiveRow');
  const activeCheckbox = document.getElementById('modalActive');
  if (!title || !description || !nameInput || !typeSelect || !activeRow || !activeCheckbox) {
    return;
  }
  title.textContent = index != null ? (kind === 'input' ? 'Modifier une entrée' : 'Modifier une sortie')
                                   : (kind === 'input' ? 'Ajouter une entrée' : 'Ajouter une sortie');
  description.textContent = kind === 'input'
    ? "Choisissez le type de mesure adapté à votre capteur."
    : "Sélectionnez le type de sortie et configurez les paramètres électriques adaptés à l'actionneur.";
  nameInput.value = data.name || '';
  nameInput.oninput = (ev) => {
    modalState.data.name = ev.target.value;
    renderModalInfoPanel(kind, modalState.data, index);
  };
  typeSelect.innerHTML = '';
  let options = typeOptionsForKind(kind);
  const isNewInput = kind === 'input' && index == null;
  if (isNewInput) {
    options = options.filter(opt => opt.value === 'adc');
    if (data.type !== 'adc') {
      data.type = 'adc';
    }
  }
  if (!options.length) {
    options = [{ value: 'disabled', label: 'Désactivée' }];
  }
  if (!isTypeAvailable(kind, data.type)) {
    const fallback = firstAvailableType(kind);
    logIoStep(`Type ${data.type} non disponible dans le formulaire, bascule vers ${fallback}.`);
    data.type = fallback;
  }
  options.forEach(opt => {
    const optionEl = document.createElement('option');
    optionEl.value = opt.value;
    optionEl.textContent = opt.label;
    typeSelect.appendChild(optionEl);
  });
  if (!data.type) {
    data.type = options[0].value;
  }
  typeSelect.value = data.type;
  typeSelect.onchange = (ev) => {
    applyTypeChange(kind, ev.target.value);
    renderModalForm();
  };
  activeCheckbox.checked = !!data.active;
  activeCheckbox.onchange = (ev) => {
    modalState.data.active = ev.target.checked;
  };
  if (kind === 'input') {
    if (isNewInput) {
      activeRow.classList.add('hidden');
      modalState.data.active = true;
    } else {
      activeRow.classList.remove('hidden');
    }
  } else {
    activeRow.classList.remove('hidden');
  }
  renderTypeSpecificFields(modalState.data, kind);
  renderModalInfoPanel(kind, modalState.data, index);
}

function handleModalSubmit(event) {
  event.preventDefault();
  if (!modalState) return;
  const { kind, index, data } = modalState;
  const isNew = index == null;
  if (!data.name || !data.name.trim()) {
    alert('Veuillez indiquer un nom.');
    return;
  }
  data.name = data.name.trim();
  logIoStep(`Enregistrement ${kind === 'input' ? 'entrée' : 'sortie'} ${data.name}`, { type: data.type, active: data.active });
  if (kind === 'input') {
    if (index != null) {
      const previous = inputs[index];
      const previousSnapshot = snapshotInput(previous, index);
      inputs[index] = data;
      const updatedSnapshot = snapshotInput(inputs[index], index);
      const prevKey = previousSnapshot.name;
      const newKey = updatedSnapshot.name;
      const newSignature = snapshotSignature(updatedSnapshot);
      const mapEntry = lastAppliedInputs.get(prevKey);
      if (prevKey === newKey && mapEntry && mapEntry.state === STATUS_SYNCED && mapEntry.signature === newSignature && snapshotSignature(previousSnapshot) === newSignature) {
        recordSyncedSnapshot('input', updatedSnapshot);
      } else {
        recordPendingSnapshot('input', updatedSnapshot, prevKey === newKey ? undefined : prevKey);
      }
    } else {
      inputs.push(data);
      const newIndex = inputs.length - 1;
      const snapshot = snapshotInput(inputs[newIndex], newIndex);
      recordPendingSnapshot('input', snapshot);
    }
    renderIoList('input');
  } else {
    if (index != null) {
      const previous = outputs[index];
      const previousSnapshot = snapshotOutput(previous, index);
      outputs[index] = data;
      const updatedSnapshot = snapshotOutput(outputs[index], index);
      const prevKey = previousSnapshot.name;
      const newKey = updatedSnapshot.name;
      const newSignature = snapshotSignature(updatedSnapshot);
      const mapEntry = lastAppliedOutputs.get(prevKey);
      if (prevKey === newKey && mapEntry && mapEntry.state === STATUS_SYNCED && mapEntry.signature === newSignature && snapshotSignature(previousSnapshot) === newSignature) {
        recordSyncedSnapshot('output', updatedSnapshot);
      } else {
        recordPendingSnapshot('output', updatedSnapshot, prevKey === newKey ? undefined : prevKey);
      }
    } else {
      outputs.push(data);
      const newIndex = outputs.length - 1;
      const snapshot = snapshotOutput(outputs[newIndex], newIndex);
      recordPendingSnapshot('output', snapshot);
    }
    renderIoList('output');
  }
  if (isNew && ioLogSession && ioLogSession.kind === kind) {
    completeIoLogSession(kind === 'input' ? 'Entrée vérifiée' : 'Sortie vérifiée');
  }
  closeIoModal(false);
}

function addInput() {
  if (inputs.length >= MAX_INPUTS) {
    alert(`Nombre maximum d'entrées atteint (${MAX_INPUTS}).`);
    return;
  }
  startIoLogSession('input');
  logIoStep('Initialisation de l\'ajout d\'une nouvelle entrée.');
  openIoModal('input', null);
}

function addOutput() {
  if (outputs.length >= MAX_OUTPUTS) {
    alert(`Nombre maximum de sorties atteint (${MAX_OUTPUTS}).`);
    return;
  }
  startIoLogSession('output');
  logIoStep('Initialisation de l\'ajout d\'une nouvelle sortie.');
  openIoModal('output', null);
}

// Load config from server and populate form
async function loadConfig() {
  try {
    const resp = await authFetch('/api/config/io/get');
    if (!resp.ok) throw new Error('Chargement impossible');
    const cfg = await resp.json();
    logIoStep('Configuration reçue du serveur');
    const metadata = cfg.metadata || {};
    const fwVersionEl = document.getElementById('fwVersion');
    if (fwVersionEl) {
      fwVersionEl.textContent = metadata.fwVersion || 'inconnue';
    }
    const modules = cfg.modules || {};
    const modAdcEl = document.getElementById('modAdc');
    if (modAdcEl) {
      modAdcEl.checked = true;
    }
    document.getElementById('modAds').checked = !!modules.ads1115;
    document.getElementById('modPwm').checked = !!modules.pwm010;
    document.getElementById('modDac').checked = !!modules.mcp4725;
    document.getElementById('modZmpt').checked = !!modules.zmpt;
    document.getElementById('modZmct').checked = !!modules.zmct;
    document.getElementById('modDiv').checked = !!modules.div;
    refreshModuleStateFromForm();
    logIoStep('Modules synchronisés lors du chargement', { ...moduleState });
    inputs = Array.isArray(cfg.inputs) ? cfg.inputs.slice(0, MAX_INPUTS).map(normaliseInput) : [];
    outputs = Array.isArray(cfg.outputs) ? cfg.outputs.slice(0, MAX_OUTPUTS).map(normaliseOutput) : [];
    ensureTypeAvailability('input');
    ensureTypeAvailability('output');
    resetSnapshotsFromConfig('input', inputs);
    resetSnapshotsFromConfig('output', outputs);
    renderIoList('input');
    renderIoList('output');
    markRebootPrompt(false);
    logIoStep('Configuration appliquée', { inputs: inputs.length, outputs: outputs.length });
  } catch (err) {
    console.error(err);
    logIoStep('Erreur lors du chargement de la configuration', err);
    document.getElementById('status').textContent = 'Erreur lors du chargement de la configuration.';
  }
}

// Serialize form to config JSON and post to server
async function saveConfig() {
  const statusEl = document.getElementById('status');
  if (saveInProgress) {
    if (statusEl) {
      statusEl.textContent = 'Une sauvegarde est déjà en cours...';
    }
    return;
  }

  const saveBtnEl = document.getElementById('saveBtn');
  const rebootBtn = document.getElementById('rebootBtn');
  const originalLabel = saveBtnEl ? (saveBtnEl.dataset.label || saveBtnEl.textContent) : '';

  const restoreUi = () => {
    if (saveBtnEl) {
      saveBtnEl.disabled = false;
      if (saveBtnEl.dataset.label) {
        saveBtnEl.textContent = saveBtnEl.dataset.label;
      }
    }
    if (rebootBtn) {
      rebootBtn.disabled = false;
    }
    saveInProgress = false;
    allowSaveProgressClose();
  };

  saveInProgress = true;
  if (saveBtnEl) {
    if (!saveBtnEl.dataset.label) {
      saveBtnEl.dataset.label = originalLabel || 'Sauvegarder';
    }
    saveBtnEl.textContent = 'Sauvegarde en cours...';
    saveBtnEl.disabled = true;
  }
  if (rebootBtn) {
    rebootBtn.disabled = true;
  }
  if (statusEl) {
    statusEl.textContent = 'Sauvegarde en cours...';
  }

  openSaveProgressModal();
  appendSaveProgressEvent('Préparation de la configuration locale', 'start');

  let payload = '';
  try {
    const cfg = {};
    cfg.modules = {
      ads1115: !!moduleState.ads1115,
      pwm010: !!moduleState.pwm010,
      mcp4725: !!moduleState.mcp4725,
      zmpt: !!moduleState.zmpt,
      zmct: !!moduleState.zmct,
      div: !!moduleState.div,
    };
    cfg.inputs = inputs.slice(0, MAX_INPUTS).map((item, idx) => {
      const obj = {
        name: item.name || `IN${idx + 1}`,
        type: item.type,
        active: !!item.active,
      };
      if (['adc', 'zmpt', 'zmct', 'div'].includes(item.type)) {
        obj.pin = item.pin || 'A0';
      }
      if (item.type === 'ads1115') {
        obj.adsChannel = toInteger(item.adsChannel, 0, { min: 0, max: 3 });
      }
      if (item.type === 'remote') {
        obj.remoteNode = item.remoteNode || '';
        obj.remoteName = item.remoteName || '';
      }
      return obj;
    });
    cfg.inputCount = cfg.inputs.length;
    cfg.outputs = outputs.slice(0, MAX_OUTPUTS).map((item, idx) => {
      const obj = {
        name: item.name || `OUT${idx + 1}`,
        type: item.type,
        active: !!item.active,
      };
      if (['pwm010', 'gpio'].includes(item.type)) {
        obj.pin = item.pin || '';
      }
      if (item.type === 'pwm010') {
        obj.pwmFreq = toInteger(item.pwmFreq, 2000, { min: 1 });
      }
      if (item.type === 'mcp4725') {
        obj.i2cAddress = item.i2cAddress && item.i2cAddress.length
          ? item.i2cAddress
          : '0x60';
      }
      return obj;
    });
    cfg.outputCount = cfg.outputs.length;
    payload = JSON.stringify(cfg);
  } catch (err) {
    console.error(err);
    appendSaveProgressEvent(
      'Fin : préparation de la configuration locale (erreur)',
      'finish',
      false,
    );
    if (statusEl) {
      statusEl.textContent = 'Erreur lors de la préparation de la configuration.';
    }
    restoreUi();
    return;
  }

  appendSaveProgressEvent('Fin : préparation de la configuration locale', 'finish', true);
  appendSaveProgressEvent('Envoi de la configuration au serveur', 'start');

  let serverResult = null;
  let rawBody = '';

  try {
    const response = await authFetch('/api/config/io/set', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: payload,
    });
    rawBody = await response.text();
    if (rawBody && rawBody.trim().length) {
      try {
        serverResult = JSON.parse(rawBody);
      } catch (err) {
        console.warn('Réponse JSON inattendue lors de la sauvegarde IO', err, rawBody);
      }
    }

    appendSaveProgressEvent(
      response.ok
        ? 'Fin : envoi de la configuration (réussi)'
        : 'Fin : envoi de la configuration (échec)',
      'finish',
      response.ok,
    );

    if (serverResult && Array.isArray(serverResult.events)) {
      serverResult.events.forEach(ev => {
        if (!ev || typeof ev.message !== 'string') return;
        const type = ev.type === 'finish' ? 'finish' : 'start';
        const success = ev.success !== false;
        appendSaveProgressEvent(ev.message, type, success);
      });
    }

    if (!response.ok) {
      if (statusEl) {
        if (serverResult && serverResult.error) {
          const detail = serverResult.detail ? ` (${serverResult.detail})` : '';
          statusEl.textContent = `Erreur lors de la sauvegarde (${serverResult.error}${detail})`;
        } else if (rawBody && rawBody.trim().length) {
          statusEl.textContent = `Erreur lors de la sauvegarde (${rawBody.trim()})`;
        } else {
          statusEl.textContent = `Erreur lors de la sauvegarde (${response.status})`;
        }
      }
      return;
    }

    rebootShouldBeEnabled = serverResult && typeof serverResult.requiresReboot === 'boolean'
      ? !!serverResult.requiresReboot
      : false;
    if (statusEl) {
      if (serverResult && typeof serverResult.message === 'string' && serverResult.message.length) {
        statusEl.textContent = serverResult.message;
      } else {
        statusEl.textContent = 'Configuration sauvegardée sans redémarrage.';
      }
    }
    markAllSnapshotsSaved();
    markRebootPrompt(rebootShouldBeEnabled);
    logIoStep('Configuration IO sauvegardée côté serveur', {
      inputs: inputs.length,
      outputs: outputs.length,
      response: serverResult || rawBody,
    });
  } catch (err) {
    console.error(err);
    appendSaveProgressEvent('Fin : envoi de la configuration (erreur)', 'finish', false);
    if (statusEl) {
      const message = describeErrorMessage(err, 'erreur inconnue');
      statusEl.textContent = `Erreur lors de la sauvegarde (${message}).`;
    }
  } finally {
    restoreUi();
  }
}

async function requestReboot(statusTarget) {
  const target = statusTarget || document.getElementById('status');
  if (target) {
    target.textContent = 'Redémarrage en cours...';
  }
  try {
    await authFetch('/api/reboot', { method: 'POST' });
    if (target) {
      target.textContent = 'Redémarrage demandé. L’équipement va redémarrer.';
    }
    return true;
  } catch (err) {
    if (target) {
      const message = describeErrorMessage(err, 'erreur inconnue');
      target.textContent = `Échec du redémarrage (${message})`;
    }
    return false;
  }
}

// Show/hide STA config depending on mode
// Event listeners
window.addEventListener('DOMContentLoaded', () => {
  refreshModuleStateFromForm();
  const addInputBtn = document.getElementById('addInputBtn');
  if (addInputBtn) {
    addInputBtn.addEventListener('click', addInput);
  }
  const addOutputBtn = document.getElementById('addOutputBtn');
  if (addOutputBtn) {
    addOutputBtn.addEventListener('click', addOutput);
  }
  ['modAdc','modAds','modPwm','modDac','modZmpt','modZmct','modDiv'].forEach(id => {
    const checkbox = document.getElementById(id);
    if (checkbox) {
      checkbox.addEventListener('change', handleModuleStateChange);
    }
  });
  const modalForm = document.getElementById('modalForm');
  if (modalForm) {
    modalForm.addEventListener('submit', handleModalSubmit);
  }
  const modalCancel = document.getElementById('modalCancel');
  if (modalCancel) {
    modalCancel.addEventListener('click', () => closeIoModal(true));
  }
  const modal = document.getElementById('ioModal');
  if (modal) {
    modal.addEventListener('click', (ev) => {
      if (ev.target === modal) {
        closeIoModal(true);
      }
    });
  }
  window.addEventListener('keydown', (ev) => {
    if (ev.key === 'Escape') {
      if (modalState) {
        closeIoModal(true);
      } else if (!saveInProgress && saveProgressModal && !saveProgressModal.classList.contains('hidden')) {
        closeSaveProgressModal();
      }
    }
  });
  renderIoList('input');
  renderIoList('output');
  ensureSession()
    .then(() => {
      loadConfig();
    })
    .catch(err => {
      console.error(err);
    });
  saveProgressModal = document.getElementById('saveProgressModal');
  saveProgressList = document.getElementById('saveProgressList');
  saveProgressClose = document.getElementById('saveProgressClose');
  if (saveProgressClose) {
    saveProgressClose.addEventListener('click', () => {
      if (!saveInProgress) {
        closeSaveProgressModal();
      }
    });
  }
  if (saveProgressModal) {
    saveProgressModal.addEventListener('click', (ev) => {
      if (ev.target === saveProgressModal && !saveInProgress) {
        closeSaveProgressModal();
      }
    });
  }
  const saveBtn = document.getElementById('saveBtn');
  if (saveBtn) {
    saveBtn.addEventListener('click', () => {
      saveConfig();
    });
  }
  const rebootBtnEl = document.getElementById('rebootBtn');
  if (rebootBtnEl) {
    rebootBtnEl.addEventListener('click', async () => {
      const statusEl = document.getElementById('status');
      if (saveInProgress) {
        if (statusEl) {
          statusEl.textContent = 'Sauvegarde en cours, redémarrage différé.';
        }
        return;
      }
      rebootBtnEl.disabled = true;
      let rebootSucceeded = false;
      try {
        rebootSucceeded = await requestReboot(statusEl);
      } finally {
        rebootBtnEl.disabled = saveInProgress;
      }
      if (rebootSucceeded) {
        markRebootPrompt(false);
      }
    });
  }
  const fwRebootBtn = document.getElementById('fwRebootBtn');
  if (fwRebootBtn) {
    fwRebootBtn.addEventListener('click', async () => {
      fwRebootBtn.disabled = true;
      try {
        const succeeded = await requestReboot(document.getElementById('fwStatus'));
        if (succeeded) {
          markRebootPrompt(false);
        }
      } finally {
        fwRebootBtn.disabled = false;
      }
    });
  }
  document.getElementById('fwUploadBtn').addEventListener('click', async () => {
    const file = document.getElementById('fwFile').files[0];
    const st = document.getElementById('fwStatus');
    if (!file) { st.textContent = 'Choisir un fichier'; return; }
    const formData = new FormData();
    formData.append('firmware', file, file.name);
    st.textContent = 'Téléversement...';
    try {
      const resp = await authFetch('/api/ota', {method: 'POST', body: formData});
      if (resp.ok) {
        st.textContent = 'Mise à jour envoyée, redémarrage...';
      } else {
        let message = 'Échec de la mise à jour';
        try {
          const data = await resp.clone().json();
          if (data && data.error) {
            message = `Échec de la mise à jour (${data.error})`;
          }
        } catch (jsonErr) {
          try {
            const text = await resp.text();
            if (text) {
              message = `Échec de la mise à jour (${text})`;
            }
          } catch (_) {
            // Ignore text parsing errors
          }
        }
        st.textContent = message;
      }
    } catch (err) {
      st.textContent = 'Erreur de mise à jour';
    }
  });
});
</script>
</body>
</html>
