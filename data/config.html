<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Configuration MiniLabBox</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 1em; }
    h1 { margin-top: 0; }
    fieldset { border: 1px solid #ccc; padding: 1em; margin-bottom: 1em; }
    legend { font-weight: bold; }
    table { border-collapse: collapse; width: 100%; margin-top: 0.5em; }
    th, td { border: 1px solid #ccc; padding: 0.3em 0.5em; }
    tr:nth-child(even) { background-color: #f8f8f8; }
    input[type="number"] { width: 80px; }
    input[type="text"] { width: 120px; }
    select { width: 120px; }
    .small { width: 60px; }
    .hidden { display: none; }
    label.inline { display: inline-block; margin-right: 0.5em; }
    button { padding: 0.5em 1em; font-size: 1em; }
    #cacheAceStatus { margin-top: 0.5em; color: #555; font-size: 0.9em; }
    #cacheAceStatus.error { color: #c0392b; }
    .hint { font-size: 0.9em; color: #555; margin-top: 0.3em; }
    input.peer-pin { width: 70px; text-align: center; }
  </style>
  <script src="auth.js"></script>
</head>
<body>
<h1>Configuration MiniLabBox</h1>

<form id="configForm" onsubmit="return false;">
  <fieldset>
    <legend>Identifiant et Réseau</legend>
    <label class="inline" for="nodeId">Identifiant du nœud :</label>
    <input type="text" id="nodeId" name="nodeId">
    <br><br>
    <label class="inline" for="wifiMode">Mode Wi-Fi :</label>
    <select id="wifiMode" name="wifiMode">
      <option value="AP">Point d'accès (AP)</option>
      <option value="STA">Client (STA)</option>
    </select>
    <br><br>
    <div id="staConfig">
      <label class="inline" for="ssid">SSID :</label>
      <input type="text" id="ssid" name="ssid">
      <label class="inline" for="pass">Mot de passe :</label>
      <input type="text" id="pass" name="pass">
    </div>
    <div id="apInfo" class="hidden">
      Ce nœud diffusera son propre réseau Wi-Fi avec l'ID ci-dessus comme SSID.
    </div>
  </fieldset>

  <fieldset>
    <legend>Modules optionnels</legend>
    <label><input type="checkbox" id="modAds"> ADC externe ADS1115</label><br>
    <label><input type="checkbox" id="modPwm"> Convertisseur PWM → 0–10 V</label><br>
    <label><input type="checkbox" id="modZmpt"> Capteur de tension AC (ZMPT101B)</label><br>
    <label><input type="checkbox" id="modZmct"> Capteur de courant AC (ZMCT103C)</label><br>
    <label><input type="checkbox" id="modDiv"> Pont diviseur DC</label>
  </fieldset>

  <fieldset>
    <legend>Entrées</legend>
    <table id="inputsTable">
      <thead>
        <tr><th>Actif</th><th>Nom</th><th>Type</th><th>Paramètres</th><th>Échelle</th><th>Décalage</th><th>Unité</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </fieldset>

  <fieldset>
    <legend>Sorties</legend>
    <table id="outputsTable">
      <thead>
        <tr><th>Actif</th><th>Nom</th><th>Type</th><th>Paramètres</th><th>Gain</th><th>Décalage</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </fieldset>

  <fieldset>
    <legend>MiniLabBox sur le réseau</legend>
    <p>Liste des MiniLabBox détectées sur le réseau local. Indiquez le code PIN pour autoriser les requêtes sécurisées.</p>
    <button type="button" id="scanBtn">Scanner le réseau local</button>
    <table id="discoveryTable">
      <thead>
        <tr><th>Identifiant</th><th>Adresse IP</th><th>Dernière vue</th><th>Code PIN</th></tr>
      </thead>
      <tbody></tbody>
    </table>
    <div id="discoveryStatus" class="hint"></div>
  </fieldset>

  <fieldset>
    <legend>Firmware</legend>
    Version actuelle : <span id="fwVersion">?</span><br><br>
    <input type="file" id="fwFile">
    <button type="button" id="fwUploadBtn">Mettre à jour</button>
    <button type="button" id="rebootBtn">Redémarrer</button>
    <span id="fwStatus" style="margin-left:1em;"></span>
  </fieldset>

  <fieldset>
    <legend>Cache de l'éditeur de fichiers</legend>
    <p>Le script Ace utilisé par l'éditeur de fichiers est chargé depuis le CDN. Vous pouvez le précharger dans le cache du navigateur pour améliorer l'ouverture hors connexion. Cette opération nécessite un navigateur autorisant l'API Cache (connexion HTTPS ou contexte sécurisé).</p>
    <button type="button" id="cacheAceBtn">Mettre en cache la librairie</button>
    <button type="button" id="cacheAceClearBtn">Vider le cache</button>
    <div id="cacheAceStatus"></div>
  </fieldset>

  <button id="saveBtn">Enregistrer et redémarrer</button>
  <span id="status" style="margin-left:1em;"></span>
</form>

<script>
const MAX_INPUTS = 4;
const MAX_OUTPUTS = 2;
const ACE_CACHE_NAME = 'minilabbox-ace-cache';
const ACE_CDN_URL = 'https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.14/ace.js';
let aceCacheStatusEl;
let aceCacheBtn;
let aceCacheClearBtn;
let discoveryTableBody;
let discoveryStatusEl;
let discoveryTimer = null;
const knownPeers = new Map();
let discoveryData = [];

// Create rows for inputs and outputs based on constants
function buildTables() {
  const inTBody = document.querySelector('#inputsTable tbody');
  const outTBody = document.querySelector('#outputsTable tbody');
  for (let i = 0; i < MAX_INPUTS; i++) {
    const tr = document.createElement('tr');
    tr.dataset.idx = i;
    // Active checkbox
    const tdActive = document.createElement('td');
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.className = 'in-active';
    tdActive.appendChild(cb);
    tr.appendChild(tdActive);
    // Name
    const tdName = document.createElement('td');
    const inpName = document.createElement('input');
    inpName.type = 'text';
    inpName.className = 'in-name';
    inpName.placeholder = 'IN' + (i+1);
    tdName.appendChild(inpName);
    tr.appendChild(tdName);
    // Type
    const tdType = document.createElement('td');
    const sel = document.createElement('select');
    sel.className = 'in-type';
    ['disabled','adc','ads1115','remote','zmpt','zmct','div'].forEach(opt => {
      const o = document.createElement('option');
      o.value = opt;
      o.textContent = opt;
      sel.appendChild(o);
    });
    tdType.appendChild(sel);
    tr.appendChild(tdType);
    // Params
    const tdParam = document.createElement('td');
    tdParam.className = 'in-param';
    tdParam.innerHTML = '';
    tr.appendChild(tdParam);
    // Scale
    const tdScale = document.createElement('td');
    const inpScale = document.createElement('input');
    inpScale.type = 'number'; inpScale.step = 'any'; inpScale.className = 'in-scale'; inpScale.value = '1';
    tdScale.appendChild(inpScale);
    tr.appendChild(tdScale);
    // Offset
    const tdOff = document.createElement('td');
    const inpOff = document.createElement('input');
    inpOff.type = 'number'; inpOff.step = 'any'; inpOff.className = 'in-offset'; inpOff.value = '0';
    tdOff.appendChild(inpOff);
    tr.appendChild(tdOff);
    // Unit
    const tdUnit = document.createElement('td');
    const inpUnit = document.createElement('input');
    inpUnit.type = 'text'; inpUnit.className = 'in-unit';
    tdUnit.appendChild(inpUnit);
    tr.appendChild(tdUnit);
    inTBody.appendChild(tr);
  }
  for (let i = 0; i < MAX_OUTPUTS; i++) {
    const tr = document.createElement('tr');
    tr.dataset.idx = i;
    const tdActive = document.createElement('td');
    const cb = document.createElement('input');
    cb.type = 'checkbox'; cb.className = 'out-active';
    tdActive.appendChild(cb);
    tr.appendChild(tdActive);
    const tdName = document.createElement('td');
    const inpName = document.createElement('input');
    inpName.type = 'text'; inpName.className = 'out-name'; inpName.placeholder = 'OUT' + (i+1);
    tdName.appendChild(inpName);
    tr.appendChild(tdName);
    const tdType = document.createElement('td');
    const sel = document.createElement('select'); sel.className = 'out-type';
    ['disabled','pwm010','gpio'].forEach(opt => {
      const o = document.createElement('option'); o.value = opt; o.textContent = opt;
      sel.appendChild(o);
    });
    tdType.appendChild(sel);
    tr.appendChild(tdType);
    const tdParam = document.createElement('td'); tdParam.className = 'out-param'; tr.appendChild(tdParam);
    const tdScale = document.createElement('td');
    const inpScale = document.createElement('input'); inpScale.type='number'; inpScale.step='any'; inpScale.className='out-scale'; inpScale.value='1';
    tdScale.appendChild(inpScale);
    tr.appendChild(tdScale);
    const tdOff = document.createElement('td');
    const inpOff = document.createElement('input'); inpOff.type='number'; inpOff.step='any'; inpOff.className='out-offset'; inpOff.value='0';
    tdOff.appendChild(inpOff);
    tr.appendChild(tdOff);
    outTBody.appendChild(tr);
  }
}

// Update param cell based on selected type
function updateInputParam(row) {
  const type = row.querySelector('.in-type').value;
  const paramCell = row.querySelector('.in-param');
  paramCell.innerHTML = '';
  if (type === 'adc') {
    const selPin = document.createElement('select');
    selPin.className = 'param-pin';
    ['A0'].concat(['D0','D1','D2','D3','D4','D5','D6','D7','D8']).forEach(p => {
      const o = document.createElement('option'); o.value = p; o.textContent = p; selPin.appendChild(o);
    });
    paramCell.appendChild(document.createTextNode('Pin :'));
    paramCell.appendChild(selPin);
  } else if (type === 'ads1115') {
    const selCh = document.createElement('select'); selCh.className = 'param-ads';
    [0,1,2,3].forEach(n => {
      const o = document.createElement('option'); o.value = n; o.textContent = 'A'+n; selCh.appendChild(o);
    });
    paramCell.appendChild(document.createTextNode('Canal :'));
    paramCell.appendChild(selCh);
  } else if (type === 'remote') {
    const inpNode = document.createElement('input'); inpNode.type = 'text'; inpNode.placeholder = 'nœud'; inpNode.className='param-remote-node';
    const inpName = document.createElement('input'); inpName.type = 'text'; inpName.placeholder = 'entrée'; inpName.className='param-remote-name';
    paramCell.appendChild(document.createTextNode('Nœud :'));
    paramCell.appendChild(inpNode);
    paramCell.appendChild(document.createElement('br'));
    paramCell.appendChild(document.createTextNode('Nom :'));
    paramCell.appendChild(inpName);
  } else if (type === 'div' || type === 'zmpt' || type === 'zmct') {
    const selPin = document.createElement('select'); selPin.className = 'param-pin';
    ['A0'].concat(['D0','D1','D2','D3','D4','D5','D6','D7','D8']).forEach(p => {
      const o = document.createElement('option'); o.value = p; o.textContent = p; selPin.appendChild(o);
    });
    paramCell.appendChild(document.createTextNode('Pin :'));
    paramCell.appendChild(selPin);
  }
}

function updateOutputParam(row) {
  const type = row.querySelector('.out-type').value;
  const paramCell = row.querySelector('.out-param');
  paramCell.innerHTML = '';
  if (type === 'pwm010' || type === 'gpio') {
    const selPin = document.createElement('select'); selPin.className = 'param-pin';
    ['D0','D1','D2','D3','D4','D5','D6','D7','D8'].forEach(p => {
      const o = document.createElement('option'); o.value = p; o.textContent = p; selPin.appendChild(o);
    });
    paramCell.appendChild(document.createTextNode('Pin :'));
    paramCell.appendChild(selPin);
    if (type === 'pwm010') {
      const freqInp = document.createElement('input'); freqInp.type='number'; freqInp.className='param-pwm-freq'; freqInp.value='2000'; freqInp.min='1'; freqInp.max='40000';
      paramCell.appendChild(document.createElement('br'));
      paramCell.appendChild(document.createTextNode('Fréq. Hz :'));
      paramCell.appendChild(freqInp);
    }
  }
}

// Load config from server and populate form
async function loadConfig() {
  try {
    const resp = await authFetch('/api/config/get');
    if (!resp.ok) throw new Error('Chargement impossible');
    const cfg = await resp.json();
    document.getElementById('nodeId').value = cfg.nodeId || '';
    document.getElementById('wifiMode').value = cfg.wifi.mode || 'AP';
    document.getElementById('ssid').value = cfg.wifi.ssid || '';
    document.getElementById('pass').value = cfg.wifi.pass || '';
    document.getElementById('fwVersion').textContent = cfg.fwVersion || 'inconnue';
    document.getElementById('modAds').checked = cfg.modules.ads1115;
    document.getElementById('modPwm').checked = cfg.modules.pwm010;
    document.getElementById('modZmpt').checked = cfg.modules.zmpt;
    document.getElementById('modZmct').checked = cfg.modules.zmct;
    document.getElementById('modDiv').checked = cfg.modules.div;
    // Populate inputs
    const inRows = document.querySelectorAll('#inputsTable tbody tr');
    for (let i = 0; i < MAX_INPUTS; i++) {
      const row = inRows[i];
      const ic = cfg.inputs[i] || {};
      row.querySelector('.in-active').checked = ic.active || false;
      row.querySelector('.in-name').value = ic.name || '';
      row.querySelector('.in-type').value = ic.type || 'disabled';
      row.querySelector('.in-scale').value = ic.scale != null ? ic.scale : 1;
      row.querySelector('.in-offset').value = ic.offset != null ? ic.offset : 0;
      row.querySelector('.in-unit').value = ic.unit || '';
      updateInputParam(row);
      if (ic.type === 'adc' || ic.type === 'div' || ic.type === 'zmpt' || ic.type === 'zmct') {
        const selPin = row.querySelector('.param-pin');
        if (selPin) selPin.value = ic.pin != null ? ic.pin : '';
      } else if (ic.type === 'ads1115') {
        const selCh = row.querySelector('.param-ads');
        if (selCh) selCh.value = ic.adsChannel != null ? ic.adsChannel : 0;
      } else if (ic.type === 'remote') {
        const inpNode = row.querySelector('.param-remote-node');
        const inpName = row.querySelector('.param-remote-name');
        if (inpNode) inpNode.value = ic.remoteNode || '';
        if (inpName) inpName.value = ic.remoteName || '';
      }
    }
    // Populate outputs
    const outRows = document.querySelectorAll('#outputsTable tbody tr');
    for (let i = 0; i < MAX_OUTPUTS; i++) {
      const row = outRows[i];
      const oc = cfg.outputs[i] || {};
      row.querySelector('.out-active').checked = oc.active || false;
      row.querySelector('.out-name').value = oc.name || '';
      row.querySelector('.out-type').value = oc.type || 'disabled';
      row.querySelector('.out-scale').value = oc.scale != null ? oc.scale : 1;
      row.querySelector('.out-offset').value = oc.offset != null ? oc.offset : 0;
      updateOutputParam(row);
      if ((oc.type === 'pwm010' || oc.type === 'gpio')) {
        const selPin = row.querySelector('.param-pin');
        if (selPin) selPin.value = oc.pin != null ? oc.pin : '';
      }
      if (oc.type === 'pwm010') {
        const freqInp = row.querySelector('.param-pwm-freq');
        if (freqInp) freqInp.value = oc.pwmFreq != null ? oc.pwmFreq : 2000;
      }
    }
    knownPeers.clear();
    if (Array.isArray(cfg.peers)) {
      cfg.peers.forEach(peer => {
        if (peer && peer.nodeId) {
          knownPeers.set(peer.nodeId, peer.pin || '');
        }
      });
    }
    renderDiscoveryRows();
    showHideWifi();
  } catch (err) {
    console.error(err);
    document.getElementById('status').textContent = 'Erreur lors du chargement de la configuration.';
  }
}

// Serialize form to config JSON and post to server
async function saveConfig() {
  const cfg = {};
  cfg.nodeId = document.getElementById('nodeId').value || '';
  cfg.wifi = {
    mode: document.getElementById('wifiMode').value,
    ssid: document.getElementById('ssid').value || '',
    pass: document.getElementById('pass').value || ''
  };
  cfg.modules = {
    ads1115: document.getElementById('modAds').checked,
    pwm010:  document.getElementById('modPwm').checked,
    zmpt:    document.getElementById('modZmpt').checked,
    zmct:    document.getElementById('modZmct').checked,
    div:     document.getElementById('modDiv').checked
  };
  // Inputs
  cfg.inputCount = MAX_INPUTS;
  cfg.inputs = [];
  const inRows = document.querySelectorAll('#inputsTable tbody tr');
  inRows.forEach((row, idx) => {
    const active = row.querySelector('.in-active').checked;
    const name = row.querySelector('.in-name').value || ('IN'+(idx+1));
    const type = row.querySelector('.in-type').value;
    const scale = parseFloat(row.querySelector('.in-scale').value) || 1;
    const offset = parseFloat(row.querySelector('.in-offset').value) || 0;
    const unit = row.querySelector('.in-unit').value || '';
    const obj = { name: name, type: type, scale: scale, offset: offset, unit: unit, active: active };
    if (type === 'adc' || type === 'div' || type === 'zmpt' || type === 'zmct') {
      const selPin = row.querySelector('.param-pin');
      obj.pin = selPin ? selPin.value : '';
    } else if (type === 'ads1115') {
      const selCh = row.querySelector('.param-ads');
      obj.adsChannel = selCh ? parseInt(selCh.value) : 0;
    } else if (type === 'remote') {
      const inpNode = row.querySelector('.param-remote-node');
      const inpName = row.querySelector('.param-remote-name');
      obj.remoteNode = inpNode ? inpNode.value : '';
      obj.remoteName = inpName ? inpName.value : '';
    }
    cfg.inputs.push(obj);
  });
  // Outputs
  cfg.outputCount = MAX_OUTPUTS;
  cfg.outputs = [];
  const outRows = document.querySelectorAll('#outputsTable tbody tr');
  outRows.forEach((row, idx) => {
    const active = row.querySelector('.out-active').checked;
    const name = row.querySelector('.out-name').value || ('OUT'+(idx+1));
    const type = row.querySelector('.out-type').value;
    const scale = parseFloat(row.querySelector('.out-scale').value) || 1;
    const offset = parseFloat(row.querySelector('.out-offset').value) || 0;
    const obj = { name: name, type: type, scale: scale, offset: offset, active: active };
    if (type === 'pwm010' || type === 'gpio') {
      const selPin = row.querySelector('.param-pin');
      obj.pin = selPin ? selPin.value : '';
    }
    if (type === 'pwm010') {
      const freqInp = row.querySelector('.param-pwm-freq');
      obj.pwmFreq = freqInp ? parseInt(freqInp.value) : 2000;
    }
    cfg.outputs.push(obj);
  });
  cfg.peers = [];
  knownPeers.forEach((pin, nodeId) => {
    if (!nodeId) return;
    cfg.peers.push({ nodeId, pin: pin || '' });
  });
  cfg.peerCount = cfg.peers.length;

  // Post config
  try {
    const resp = await authFetch('/api/config/set', {
      method: 'POST',
      // The firmware expects a plain text body for configuration updates.
      // Sending JSON with a text/plain content type allows the server to
      // access the payload via the "plain" parameter.
      headers: { 'Content-Type': 'text/plain' },
      body: JSON.stringify(cfg)
    });
    if (resp.ok) {
      document.getElementById('status').textContent = 'Sauvegarde réussie, redémarrage...';
    } else {
      document.getElementById('status').textContent = 'Erreur lors de la sauvegarde';
    }
  } catch (err) {
    console.error(err);
    document.getElementById('status').textContent = 'Erreur lors de la sauvegarde';
  }
}

// Show/hide STA config depending on mode
function showHideWifi() {
  const mode = document.getElementById('wifiMode').value;
  const sta = document.getElementById('staConfig');
  const ap = document.getElementById('apInfo');
  if (mode === 'STA') {
    sta.classList.remove('hidden');
    ap.classList.add('hidden');
  } else {
    sta.classList.add('hidden');
    ap.classList.remove('hidden');
  }
}

function formatAge(ageMs) {
  if (ageMs == null) return '—';
  const seconds = ageMs / 1000;
  if (seconds < 1) return 'juste maintenant';
  if (seconds < 60) return `${seconds.toFixed(1)} s`;
  const minutes = seconds / 60;
  if (minutes < 60) return `${minutes.toFixed(1)} min`;
  const hours = minutes / 60;
  return `${hours.toFixed(1)} h`;
}

function renderDiscoveryRows() {
  if (!discoveryTableBody) return;
  discoveryTableBody.innerHTML = '';
  const combined = [];
  const seen = new Set();
  discoveryData.forEach(node => {
    if (!node || !node.nodeId) return;
    combined.push(node);
    seen.add(node.nodeId);
    if (!knownPeers.has(node.nodeId)) {
      knownPeers.set(node.nodeId, '');
    }
  });
  knownPeers.forEach((pin, nodeId) => {
    if (!nodeId || seen.has(nodeId)) return;
    combined.push({ nodeId, ip: '', ageMs: null });
  });

  if (combined.length === 0) {
    const row = document.createElement('tr');
    const cell = document.createElement('td');
    cell.colSpan = 4;
    cell.textContent = 'Aucune MiniLabBox détectée pour le moment.';
    row.appendChild(cell);
    discoveryTableBody.appendChild(row);
    return;
  }

  combined.sort((a, b) => a.nodeId.localeCompare(b.nodeId));
  combined.forEach(node => {
    const row = document.createElement('tr');
    row.dataset.nodeId = node.nodeId;
    const tdId = document.createElement('td');
    tdId.textContent = node.nodeId;
    const tdIp = document.createElement('td');
    tdIp.textContent = node.ip && node.ip.length ? node.ip : '—';
    const tdAge = document.createElement('td');
    tdAge.textContent = formatAge(node.ageMs);
    const tdPin = document.createElement('td');
    const input = document.createElement('input');
    input.type = 'text';
    input.maxLength = 4;
    input.className = 'peer-pin';
    input.placeholder = '0000';
    input.value = knownPeers.get(node.nodeId) || '';
    input.addEventListener('input', () => {
      knownPeers.set(node.nodeId, input.value.trim());
    });
    tdPin.appendChild(input);
    row.appendChild(tdId);
    row.appendChild(tdIp);
    row.appendChild(tdAge);
    row.appendChild(tdPin);
    discoveryTableBody.appendChild(row);
  });
}

async function refreshDiscovery() {
  if (!discoveryStatusEl) return;
  discoveryStatusEl.textContent = 'Scan en cours...';
  try {
    const resp = await authFetch('/api/discovery');
    if (!resp.ok) throw new Error('Scan impossible');
    const data = await resp.json();
    let list = [];
    if (Array.isArray(data)) {
      list = data;
    } else if (data && Array.isArray(data.nodes)) {
      list = data.nodes;
    }
    discoveryData = list.map(item => ({
      nodeId: item && item.nodeId ? item.nodeId : '',
      ip: item && item.ip ? item.ip : '',
      ageMs: typeof item.ageMs === 'number' ? item.ageMs : null
    }));
    renderDiscoveryRows();
    if (discoveryData.length) {
      discoveryStatusEl.textContent = `Dernière mise à jour : ${new Date().toLocaleTimeString()}`;
    } else {
      discoveryStatusEl.textContent = 'Aucune MiniLabBox détectée pour le moment.';
    }
  } catch (err) {
    console.error(err);
    discoveryStatusEl.textContent = 'Échec du scan du réseau.';
  }
}

function setAceStatus(text, isError = false) {
  if (!aceCacheStatusEl) return;
  aceCacheStatusEl.textContent = text;
  if (isError) {
    aceCacheStatusEl.classList.add('error');
  } else {
    aceCacheStatusEl.classList.remove('error');
  }
}

async function updateAceCacheStatus() {
  if (!aceCacheStatusEl || !aceCacheBtn || !aceCacheClearBtn) return;
  if (!('caches' in window)) {
    aceCacheBtn.disabled = true;
    aceCacheClearBtn.disabled = true;
    aceCacheBtn.classList.add('hidden');
    aceCacheClearBtn.classList.add('hidden');
    const reason = window.isSecureContext
      ? 'fonction non prise en charge par ce navigateur.'
      : 'fonction disponible uniquement via une connexion HTTPS.';
    setAceStatus(`Mise en cache indisponible (${reason})`);
    return;
  }
  aceCacheBtn.classList.remove('hidden');
  aceCacheClearBtn.classList.remove('hidden');
  try {
    const keys = await caches.keys();
    const hasCache = keys.includes(ACE_CACHE_NAME);
    let cached = false;
    if (hasCache) {
      const cache = await caches.open(ACE_CACHE_NAME);
      const match = await cache.match(ACE_CDN_URL);
      cached = !!match;
    }
    const timestamp = localStorage.getItem('aceCacheTimestamp');
    if (cached) {
      const readable = timestamp ? new Date(timestamp).toLocaleString() : 'inconnue';
      setAceStatus(`Librairie en cache (mise à jour : ${readable}).`);
      aceCacheBtn.textContent = 'Actualiser le cache';
      aceCacheClearBtn.disabled = false;
    } else {
      setAceStatus('Librairie non mise en cache.');
      aceCacheBtn.textContent = 'Mettre en cache la librairie';
      aceCacheClearBtn.disabled = !hasCache;
    }
    aceCacheBtn.disabled = false;
  } catch (err) {
    console.error(err);
    setAceStatus('Erreur lors de l’accès au cache.', true);
    aceCacheBtn.disabled = false;
    aceCacheClearBtn.disabled = false;
  }
}

async function cacheAceLibrary() {
  if (!('caches' in window) || !aceCacheBtn) return;
  aceCacheBtn.disabled = true;
  setAceStatus('Mise en cache en cours...');
  let errorMessage = '';
  try {
    const cache = await caches.open(ACE_CACHE_NAME);
    await cache.add(new Request(ACE_CDN_URL, { mode: 'cors' }));
    localStorage.setItem('aceCacheTimestamp', new Date().toISOString());
  } catch (err) {
    console.error(err);
    errorMessage = `Échec de la mise en cache : ${err.message}`;
  }
  await updateAceCacheStatus();
  if (errorMessage) {
    setAceStatus(errorMessage, true);
  }
}

async function clearAceCache() {
  if (!('caches' in window) || !aceCacheClearBtn) return;
  aceCacheClearBtn.disabled = true;
  setAceStatus('Suppression du cache...');
  let errorMessage = '';
  try {
    await caches.delete(ACE_CACHE_NAME);
    localStorage.removeItem('aceCacheTimestamp');
  } catch (err) {
    console.error(err);
    errorMessage = `Erreur lors de la suppression du cache : ${err.message}`;
  }
  await updateAceCacheStatus();
  if (errorMessage) {
    setAceStatus(errorMessage, true);
  }
}

// Event listeners
window.addEventListener('DOMContentLoaded', () => {
  buildTables();
  discoveryTableBody = document.querySelector('#discoveryTable tbody');
  discoveryStatusEl = document.getElementById('discoveryStatus');
  const scanBtn = document.getElementById('scanBtn');
  if (scanBtn) {
    scanBtn.addEventListener('click', () => {
      refreshDiscovery();
    });
  }
  renderDiscoveryRows();
  ensureSession()
    .then(() => {
      loadConfig();
      refreshDiscovery();
      if (discoveryTimer) clearInterval(discoveryTimer);
      discoveryTimer = setInterval(refreshDiscovery, 8000);
    })
    .catch(err => {
      console.error(err);
      if (discoveryStatusEl) {
        discoveryStatusEl.textContent = 'Session requise pour scanner le réseau.';
      }
    });
  // Update input param cells when type changes
  document.querySelector('#inputsTable').addEventListener('change', (e) => {
    if (e.target.classList.contains('in-type')) {
      const row = e.target.closest('tr');
      updateInputParam(row);
    }
  });
  document.querySelector('#outputsTable').addEventListener('change', (e) => {
    if (e.target.classList.contains('out-type')) {
      const row = e.target.closest('tr');
      updateOutputParam(row);
    }
  });
  document.getElementById('wifiMode').addEventListener('change', showHideWifi);
  document.getElementById('saveBtn').addEventListener('click', () => {
    document.getElementById('status').textContent = 'Sauvegarde...';
    saveConfig();
  });
  document.getElementById('rebootBtn').addEventListener('click', () => {
    document.getElementById('fwStatus').textContent = 'Redémarrage...';
    authFetch('/api/reboot', {method: 'POST'});
  });
  document.getElementById('fwUploadBtn').addEventListener('click', async () => {
    const file = document.getElementById('fwFile').files[0];
    const st = document.getElementById('fwStatus');
    if (!file) { st.textContent = 'Choisir un fichier'; return; }
    st.textContent = 'Téléversement...';
    try {
      const resp = await authFetch('/api/ota', {method: 'POST', body: file});
      if (resp.ok) {
        st.textContent = 'Mise à jour envoyée, redémarrage...';
      } else {
        st.textContent = 'Échec de la mise à jour';
      }
    } catch (err) {
      st.textContent = 'Erreur de mise à jour';
    }
  });
  aceCacheStatusEl = document.getElementById('cacheAceStatus');
  aceCacheBtn = document.getElementById('cacheAceBtn');
  aceCacheClearBtn = document.getElementById('cacheAceClearBtn');
  if (aceCacheBtn && aceCacheClearBtn && aceCacheStatusEl) {
    aceCacheBtn.addEventListener('click', cacheAceLibrary);
    aceCacheClearBtn.addEventListener('click', clearAceCache);
    updateAceCacheStatus();
  }
});
</script>
</body>
</html>