<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Configuration MiniLabBox</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 1em; }
    h1 { margin-top: 0; }
    fieldset { border: 1px solid #ccc; padding: 1em; margin-bottom: 1em; }
    legend { font-weight: bold; }
    table { border-collapse: collapse; width: 100%; margin-top: 0.5em; }
    th, td { border: 1px solid #ccc; padding: 0.3em 0.5em; }
    tr:nth-child(even) { background-color: #f8f8f8; }
    input[type="number"] { width: 80px; }
    input[type="text"] { width: 120px; }
    select { width: 120px; }
    .small { width: 60px; }
    .hidden { display: none; }
    label.inline { display: inline-block; margin-right: 0.5em; }
    button { padding: 0.5em 1em; font-size: 1em; }
    #cacheAceStatus { margin-top: 0.5em; color: #555; font-size: 0.9em; }
    #cacheAceStatus.error { color: #c0392b; }
    .hint { font-size: 0.9em; color: #555; margin-top: 0.3em; }
    input.peer-pin { width: 70px; text-align: center; }
    .io-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.6em; }
    .counter { font-size: 0.9em; color: #555; }
    .io-list { display: grid; gap: 0.75em; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); }
    .io-card { border: 1px solid #d0d0d0; border-radius: 8px; padding: 0.75em 0.9em; background: #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.08); display: flex; flex-direction: column; }
    .io-card-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 0.5em; }
    .io-card h3 { margin: 0; font-size: 1.1em; }
    .io-type { font-size: 0.85em; color: #555; text-transform: uppercase; letter-spacing: 0.05em; }
    .io-details { margin: 0.5em 0 0; padding-left: 1.1em; color: #333; }
    .io-details li { margin-bottom: 0.2em; }
    .io-empty { font-style: italic; color: #666; }
    .toggle { font-size: 0.85em; color: #333; }
    .toggle input { margin-right: 0.35em; }
    .io-status { display: inline-flex; align-items: center; gap: 0.3em; font-size: 0.8em; color: #666; margin-top: 0.2em; }
    .io-status::before { content: ''; display: inline-block; width: 0.55em; height: 0.55em; border-radius: 50%; background: #bbb; }
    .io-status.synced { color: #256029; }
    .io-status.synced::before { background: #27ae60; }
    .io-status.pending { color: #8a6d3b; }
    .io-status.pending::before { background: #f1c40f; }
    .io-status.error { color: #c0392b; }
    .io-status.error::before { background: #c0392b; }
    .io-actions { margin-top: auto; display: flex; gap: 0.5em; justify-content: flex-end; }
    button.secondary { background: #f3f3f3; border: 1px solid #bbb; color: #333; }
    button.danger { background: #c0392b; border: none; color: #fff; }
    button.secondary:hover { background: #e6e6e6; }
    button.danger:hover { background: #a93124; }
    .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.35); display: flex; align-items: center; justify-content: center; z-index: 1000; }
    .modal.hidden { display: none; }
    .modal-content { background: #fff; padding: 1.4em 1.6em; border-radius: 10px; width: min(500px, 90%); max-height: 90vh; overflow-y: auto; box-shadow: 0 18px 40px rgba(0,0,0,0.2); }
    .modal-content h2 { margin-top: 0; }
    .modal-form-row { margin-bottom: 0.75em; display: flex; flex-direction: column; }
    .modal-form-row label { font-weight: bold; margin-bottom: 0.35em; }
    .modal-form-row input[type="text"],
    .modal-form-row input[type="number"],
    .modal-form-row select { width: 100%; box-sizing: border-box; }
    .modal-actions { display: flex; justify-content: flex-end; gap: 0.6em; margin-top: 1.2em; }
    .modal-description { font-size: 0.9em; color: #555; margin-bottom: 0.9em; }
    .modal-info { background: #f2f6ff; border-left: 4px solid #3a6abf; padding: 0.75em 1em; border-radius: 6px; color: #2a3a55; font-size: 0.9em; margin-bottom: 1em; }
    .modal-info h3 { margin: 0 0 0.35em; font-size: 1em; }
    .modal-info ul { margin: 0.4em 0 0 1.2em; padding: 0; }
    .modal-info li { margin-bottom: 0.3em; }
    .io-log-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.35); display: flex; align-items: center; justify-content: center; z-index: 1500; padding: 1.5em; box-sizing: border-box; overflow-y: auto; }
    .io-log-overlay.hidden { display: none; }
    .io-log-panel { width: min(420px, 92vw); max-height: 70vh; display: flex; flex-direction: column; background: #ffffff; border-radius: 14px; box-shadow: 0 18px 35px rgba(0,0,0,0.25); border: 1px solid rgba(0,0,0,0.1); overflow: hidden; }
    .io-log-panel[data-pinned="true"] { border-color: #1f3a93; box-shadow: 0 18px 35px rgba(31,58,147,0.35); }
    .io-log-header { display: flex; align-items: center; justify-content: space-between; gap: 0.75em; background: linear-gradient(135deg, #1f3a93, #3a539b); color: #fff; padding: 0.7em 1em; font-weight: bold; font-size: 0.95em; }
    .io-log-title { flex: 1 1 auto; }
    .io-log-actions { display: flex; align-items: center; gap: 0.6em; font-weight: normal; }
    .io-log-pin-toggle { display: inline-flex; align-items: center; gap: 0.3em; font-size: 0.8em; cursor: pointer; }
    .io-log-body { display: flex; flex-direction: column; gap: 0.6em; padding: 1em 1.15em; flex: 1 1 auto; min-height: 0; box-sizing: border-box; }
    .io-log-controls { display: flex; align-items: center; justify-content: space-between; gap: 0.5em; }
    .io-log-copy-status { font-size: 0.75em; color: #2c3e50; min-height: 1.2em; }
    .io-log-copy-status.success { color: #1f7a3d; }
    .io-log-copy-status.error { color: #c0392b; }
    .io-log-list { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 0.65em; overflow-y: auto; flex: 1 1 auto; padding-right: 0.25em; }
    .io-log-step { display: flex; gap: 0.6em; align-items: flex-start; font-size: 0.9em; color: #2c3e50; }
    .io-log-icon { flex: 0 0 auto; width: 1.4em; height: 1.4em; border-radius: 50%; border: 2px solid #95a5a6; display: inline-flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.85em; color: #7f8c8d; background: #ecf0f1; margin-top: 0.2em; }
    .io-log-step.pending .io-log-icon { border-color: #95a5a6; color: #7f8c8d; background: #ecf0f1; }
    .io-log-step.completed .io-log-icon { border-color: #27ae60; background: #27ae60; color: #fff; }
    .io-log-step.aborted .io-log-icon { border-color: #c0392b; background: #c0392b; color: #fff; }
    .io-log-content { display: flex; flex-direction: column; gap: 0.3em; }
    .io-log-message { font-weight: 600; }
    .io-log-step.completed .io-log-message { color: #1f7a3d; }
    .io-log-step.aborted .io-log-message { color: #c0392b; }
    .io-log-detail { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace; font-size: 0.75em; background: #f4f6f8; border-radius: 5px; padding: 0.35em 0.5em; white-space: pre-wrap; word-break: break-word; color: #2c3e50; }
    .io-log-step.completed .io-log-detail { background: #e9f7ef; color: #1f7a3d; }
    .io-log-step.aborted .io-log-detail { background: #fdecea; color: #96281b; }
    .io-log-highlight { background: rgba(39, 174, 96, 0.12); border-radius: 8px; padding: 0.4em 0.5em; }
    button.icon-button { background: transparent; border: none; color: inherit; font-size: 1.2em; line-height: 1; cursor: pointer; padding: 0.1em; }
    button.icon-button:hover { color: #f1f1f1; }
    button.small { padding: 0.35em 0.75em; font-size: 0.85em; }
  </style>
  <script src="auth.js"></script>
</head>
<body>
<h1>Configuration MiniLabBox</h1>

<p class="hint">
  Les réglages du multimètre virtuel et des autres instruments sont désormais disponibles sur la page
  <a href="virtual-lab/settings.html">Réglages Virtual Lab</a>.
</p>

<p class="hint">
  Les paramètres Wi-Fi et l'identifiant du nœud ont été déplacés vers la page dédiée
  <a href="interface.html">Interface réseau</a>.
</p>

<form id="configForm" onsubmit="return false;">
  <fieldset>
    <legend>Modules optionnels</legend>
    <label><input type="checkbox" id="modAds"> ADC externe ADS1115</label><br>
    <label><input type="checkbox" id="modPwm"> Convertisseur PWM → 0–10 V</label><br>
    <label><input type="checkbox" id="modDac"> DAC I²C MCP4725</label><br>
    <label><input type="checkbox" id="modZmpt"> Capteur de tension AC (ZMPT101B)</label><br>
    <label><input type="checkbox" id="modZmct"> Capteur de courant AC (ZMCT103C)</label><br>
    <label><input type="checkbox" id="modDiv"> Pont diviseur DC</label>
  </fieldset>

  <fieldset>
    <legend>Entrées</legend>
    <p class="hint">Ajoutez les mesures utiles et associez chaque entrée à son capteur ou à une valeur distante.</p>
    <div class="io-header">
      <button type="button" id="addInputBtn">Ajouter une entrée</button>
      <span class="counter" id="inputsCounter">0 / 4</span>
    </div>
    <div id="inputsList" class="io-list"></div>
  </fieldset>

  <fieldset>
    <legend>Sorties</legend>
    <p class="hint">Chaque sortie peut piloter un convertisseur PWM → 0–10 V, un simple GPIO ou le nouveau DAC I²C MCP4725.</p>
    <div class="io-header">
      <button type="button" id="addOutputBtn">Ajouter une sortie</button>
      <span class="counter" id="outputsCounter">0 / 2</span>
    </div>
    <div id="outputsList" class="io-list"></div>
  </fieldset>

  <fieldset>
    <legend>Firmware</legend>
    Version actuelle : <span id="fwVersion">?</span><br><br>
    <input type="file" id="fwFile">
    <button type="button" id="fwUploadBtn">Mettre à jour</button>
    <button type="button" id="rebootBtn">Redémarrer</button>
    <span id="fwStatus" style="margin-left:1em;"></span>
  </fieldset>

  <button id="saveBtn">Enregistrer et redémarrer</button>
  <span id="status" style="margin-left:1em;"></span>
</form>

<div id="ioModal" class="modal hidden" role="dialog" aria-modal="true">
  <div class="modal-content">
    <h2 id="modalTitle">Configurer</h2>
    <p class="modal-description" id="modalDescription"></p>
    <div class="modal-info" id="modalInfo" aria-live="polite"></div>
    <form id="modalForm">
      <div class="modal-form-row">
        <label for="modalName">Nom</label>
        <input type="text" id="modalName" required>
      </div>
      <div class="modal-form-row">
        <label for="modalType">Type</label>
        <select id="modalType"></select>
      </div>
      <div class="modal-form-row">
        <label class="toggle"><input type="checkbox" id="modalActive"> Activer cette voie</label>
      </div>
      <div class="modal-form-row">
        <label for="modalScale">Échelle</label>
        <input type="number" step="any" id="modalScale">
      </div>
      <div class="modal-form-row">
        <label for="modalOffset">Décalage</label>
        <input type="number" step="any" id="modalOffset">
      </div>
      <div class="modal-form-row" id="modalUnitRow">
        <label for="modalUnit">Unité</label>
        <input type="text" id="modalUnit">
      </div>
      <div id="modalTypeFields"></div>
      <div class="modal-actions">
        <button type="button" class="secondary" id="modalCancel">Annuler</button>
        <button type="submit">Enregistrer</button>
      </div>
    </form>
  </div>
</div>

<div id="ioLogOverlay" class="io-log-overlay hidden" aria-hidden="true" role="presentation">
  <div id="ioLogPanel" class="io-log-panel" role="dialog" aria-modal="true" aria-live="polite" tabindex="-1">
    <div class="io-log-header">
      <span id="ioLogTitle" class="io-log-title">Suivi de la configuration</span>
      <div class="io-log-actions">
        <label class="io-log-pin-toggle"><input type="checkbox" id="ioLogPin"> Garder ouvert</label>
        <button type="button" id="ioLogCopyBtn" class="secondary small">Copier le journal</button>
        <button type="button" id="ioLogCloseBtn" class="icon-button" aria-label="Fermer le suivi">×</button>
      </div>
    </div>
    <div class="io-log-body">
      <div class="io-log-controls">
        <div class="io-log-copy-status" id="ioLogCopyStatus" aria-live="polite"></div>
        <span class="counter" id="ioLogStepCounter">0 étape</span>
      </div>
      <ol id="ioLogList" class="io-log-list"></ol>
    </div>
  </div>
</div>

<script>
const MAX_INPUTS = 4;
const MAX_OUTPUTS = 2;
const ANALOG_PINS = ['A0'];
const DIGITAL_PINS = ['D0','D1','D2','D3','D4','D5','D6','D7','D8'];
const ANALOG_TYPES = new Set(['adc','div','zmpt','zmct']);
const OUTPUT_PIN_TYPES = new Set(['pwm010','gpio']);
const INPUT_TYPES = [
  { value: 'adc', label: 'ADC interne (A0)' },
  { value: 'ads1115', label: 'ADC externe ADS1115' },
  { value: 'remote', label: 'Valeur distante' },
  { value: 'zmpt', label: 'Capteur tension AC (ZMPT)' },
  { value: 'zmct', label: 'Capteur courant AC (ZMCT)' },
  { value: 'div', label: 'Diviseur DC' },
  { value: 'disabled', label: 'Désactivée' }
];
const OUTPUT_TYPES = [
  { value: 'pwm010', label: 'PWM → 0–10 V' },
  { value: 'gpio', label: 'Sortie GPIO' },
  { value: 'mcp4725', label: 'DAC I²C MCP4725' },
  { value: 'disabled', label: 'Désactivée' }
];
const MODULE_DEPENDENCIES = {
  input: {
    ads1115: 'ads1115',
    zmpt: 'zmpt',
    zmct: 'zmct',
    div: 'div'
  },
  output: {
    pwm010: 'pwm010',
    mcp4725: 'mcp4725'
  }
};

const INPUT_TYPE_DETAILS = {
  adc: {
    title: 'Entrée ADC interne',
    summary: 'Utilise le convertisseur analogique-numérique intégré de l’ESP8266 sur la broche A0.',
    resolution: '10 bits (0 à 1023 codes bruts).',
    rawRange: '0 à 1023 bits mesurés.',
    physicalRange: '≈ 0 à 1,0 V sur A0 (atténuation intégrée).',
    rawTagSuffix: '_bits',
    notes: [
      'Appliquez une échelle (ex. 0,001) pour convertir les bits en volts réels.',
      'Le décalage compense un éventuel zéro non nul.'
    ]
  },
  ads1115: {
    title: 'Entrée ADS1115',
    summary: 'Lit un canal simple du convertisseur ADS1115 externe configuré en gain ×1.',
    resolution: '16 bits (0 à 32767 en mode simple).',
    rawRange: '0 à 32767 codes.',
    physicalRange: '0 à 4,096 V pour le gain par défaut.',
    rawTagSuffix: '_bits',
    notes: [
      'Chaque code représente environ 125 µV. Ajustez l’échelle pour exprimer la tension en volts.',
      'Assurez-vous d’avoir activé le module ADS1115 dans la configuration.'
    ]
  },
  remote: {
    title: 'Entrée distante',
    summary: 'Récupère une mesure diffusée par un autre MiniLabBox via UDP sécurisé.',
    notes: [
      'La plage dépend du capteur distant ; aucune conversion matérielle locale n’est appliquée.',
      'Saisissez exactement l’identifiant du nœud et le nom distant pour recevoir la valeur.'
    ]
  },
  zmpt: {
    title: 'Capteur de tension AC (ZMPT101B)',
    summary: 'Calcule la valeur RMS de la composante AC mesurée par le module ZMPT101B.',
    resolution: '10 bits (calcul RMS sur 32 échantillons).',
    rawRange: '0 à ≈512 bits RMS autour de la valeur médiane.',
    physicalRange: 'Plage proportionnelle à la tension AC après calibration.',
    rawTagSuffix: '_bits',
    notes: [
      'La valeur brute correspond à l’écart autour de 512 (centre de l’ADC).',
      'Calibrez l’échelle pour exprimer la tension efficace en volts.'
    ]
  },
  zmct: {
    title: 'Capteur de courant AC (ZMCT103C)',
    summary: 'Mesure le courant AC RMS à l’aide du transformateur ZMCT103C et de l’ADC interne.',
    resolution: '10 bits (calcul RMS sur 32 échantillons).',
    rawRange: '0 à ≈512 bits RMS autour de la valeur médiane.',
    physicalRange: 'Plage proportionnelle au courant AC selon la calibration du capteur.',
    rawTagSuffix: '_bits',
    notes: [
      'Déterminez l’échelle à partir de la sensibilité du capteur (A/bit).',
      'Un décalage positif peut compenser la dérive du zéro.'
    ]
  },
  div: {
    title: 'Pont diviseur DC',
    summary: 'Mesure une tension continue via un pont diviseur raccordé à l’ADC interne.',
    resolution: '10 bits (0 à 1023 codes).',
    rawRange: '0 à 1023 bits bruts (moyenne de 32 échantillons).',
    physicalRange: '≈ 0 à 1,0 V en entrée A0 avant application du rapport du pont.',
    rawTagSuffix: '_bits',
    notes: [
      'Ajustez l’échelle selon le rapport du pont pour retrouver la tension réelle.',
      'Le décalage corrige l’offset éventuel dû aux résistances.'
    ]
  },
  disabled: {
    title: 'Entrée désactivée',
    summary: 'La voie n’est pas utilisée tant qu’un type actif n’est pas sélectionné.',
    notes: [
      'Activez la voie et choisissez un type pour commencer la mesure.'
    ]
  }
};

const OUTPUT_TYPE_DETAILS = {
  pwm010: {
    title: 'Sortie PWM → 0–10 V',
    summary: 'Pilote un convertisseur PWM/analogique pour générer une tension 0–10 V.',
    resolution: '10 bits (0 à 1023 de rapport cyclique).',
    rawRange: '0 à 1023 (pour le rapport cyclique PWM).',
    physicalRange: '≈ 0 à 10 V après conversion.',
    notes: [
      'Envoyez la consigne en volts ; l’échelle et le décalage adaptent la conversion en PWM.',
      'Ajustez la fréquence PWM en fonction des besoins de votre module 0–10 V.'
    ]
  },
  gpio: {
    title: 'Sortie GPIO',
    summary: 'Commande directe d’un GPIO numérique de l’ESP8266.',
    resolution: '1 bit (niveau logique bas ou haut).',
    physicalRange: '0 V (LOW) ou 3,3 V (HIGH) sur la broche sélectionnée.',
    notes: [
      'Toute consigne supérieure à 0,5 est interprétée comme HIGH.',
      'Utilisez ce mode pour piloter des relais ou des LEDs avec adaptation appropriée.'
    ]
  },
  mcp4725: {
    title: 'Sortie DAC MCP4725',
    summary: 'Génère une tension analogique via le DAC I²C MCP4725.',
    resolution: '12 bits (0 à 4095 codes).',
    rawRange: '0 à 4095 codes DAC.',
    physicalRange: '0 à VCC du module (souvent 5 V).',
    notes: [
      'L’échelle traduit vos unités physiques en codes DAC (ex. 819 pour ≈1 V à 5 V).',
      'Vérifiez l’adresse I²C (0x60 ou 0x61) selon le cavalier matériel.'
    ]
  },
  disabled: {
    title: 'Sortie désactivée',
    summary: 'Aucun signal n’est généré tant que la voie reste désactivée.',
    notes: [
      'Activez la voie et choisissez un type pour la piloter.'
    ]
  }
};

function defaultIoName(kind, index) {
  const baseIndex = Number.isFinite(index) ? index : 0;
  return kind === 'input' ? `IN${baseIndex + 1}` : `OUT${baseIndex + 1}`;
}

function normaliseTagSlug(name) {
  if (!name) return '';
  const normalised = name.trim().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  const slug = normalised.replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
  return slug;
}

function getIoExplanation(kind, data, fallbackName, indexHint) {
  const dictionaries = kind === 'input' ? INPUT_TYPE_DETAILS : OUTPUT_TYPE_DETAILS;
  const typeKey = data.type && dictionaries[data.type] ? data.type : 'disabled';
  const base = dictionaries[typeKey] || dictionaries.disabled;
  let name = data.name && data.name.trim().length ? data.name.trim() : '';
  if (!name) {
    if (fallbackName) {
      name = fallbackName;
    } else {
      name = defaultIoName(kind, Number.isFinite(indexHint) ? indexHint : 0);
    }
  }
  const lines = [];
  if (name) {
    lines.push(`Tag JSON : ${name}`);
  }
  if (base.rawTagSuffix) {
    const slug = normaliseTagSlug(name);
    if (slug) {
      const rawLabel = `${slug}${base.rawTagSuffix}`;
      if (base.rawRange) {
        lines.push(`Tag brut suggéré : ${rawLabel} (${base.rawRange})`);
      } else {
        lines.push(`Tag brut suggéré : ${rawLabel}`);
      }
    }
  }
  if (base.resolution) {
    lines.push(`Résolution : ${base.resolution}`);
  }
  if (base.rawRange && !base.rawTagSuffix) {
    lines.push(`Valeur brute : ${base.rawRange}`);
  }
  if (base.physicalRange) {
    lines.push(`Plage physique : ${base.physicalRange}`);
  }
  if (Array.isArray(base.notes)) {
    base.notes.forEach(note => lines.push(note));
  }
  return {
    title: base.title,
    summary: base.summary,
    lines
  };
}

let inputs = [];
let outputs = [];
const moduleState = {
  ads1115: false,
  pwm010: false,
  mcp4725: false,
  zmpt: false,
  zmct: false,
  div: false
};
let modalState = null;
let ioLogSession = null;
let ioLogHideTimer = null;
let ioLogPinned = false;
let ioLogCopyStatusTimer = null;
const IO_LOG_AUTO_HIDE_DELAY = 4500;

const STATUS_SYNCED = 'synced';
const STATUS_PENDING = 'pending';
let lastAppliedInputs = new Map();
let lastAppliedOutputs = new Map();

function logIoStep(message, detail) {
  if (detail !== undefined) {
    console.log(`[IO] ${message}`, detail);
  } else {
    console.log(`[IO] ${message}`);
  }
  if (ioLogSession) {
    appendIoLogStep(message, detail);
  }
}

function updateIoLogPanelPinnedState() {
  const pin = document.getElementById('ioLogPin');
  if (pin) {
    pin.checked = ioLogPinned;
  }
  const panel = document.getElementById('ioLogPanel');
  if (panel) {
    panel.dataset.pinned = ioLogPinned ? 'true' : 'false';
  }
}

function updateIoLogStepCounter() {
  const counter = document.getElementById('ioLogStepCounter');
  if (!counter) return;
  const list = document.getElementById('ioLogList');
  const count = list ? list.querySelectorAll('.io-log-step').length : 0;
  counter.textContent = count <= 1 ? `${count} étape` : `${count} étapes`;
}

function showIoLogPanel() {
  const overlay = document.getElementById('ioLogOverlay');
  const panel = document.getElementById('ioLogPanel');
  if (overlay) {
    overlay.classList.remove('hidden');
    overlay.setAttribute('aria-hidden', 'false');
  }
  if (panel) {
    panel.setAttribute('aria-hidden', 'false');
    try {
      panel.focus({ preventScroll: true });
    } catch (_) {
      panel.focus();
    }
  }
  updateIoLogPanelPinnedState();
}

function hideIoLogPanel(force = false) {
  if (!force && ioLogPinned) {
    return;
  }
  if (ioLogHideTimer) {
    clearTimeout(ioLogHideTimer);
    ioLogHideTimer = null;
  }
  const overlay = document.getElementById('ioLogOverlay');
  const panel = document.getElementById('ioLogPanel');
  if (overlay) {
    overlay.classList.add('hidden');
    overlay.setAttribute('aria-hidden', 'true');
  }
  if (panel) {
    panel.setAttribute('aria-hidden', 'true');
  }
}

function scheduleIoLogHide() {
  if (ioLogPinned) {
    return;
  }
  if (ioLogHideTimer) {
    clearTimeout(ioLogHideTimer);
  }
  ioLogHideTimer = setTimeout(() => {
    if (!ioLogPinned) {
      hideIoLogPanel();
    }
    ioLogHideTimer = null;
  }, IO_LOG_AUTO_HIDE_DELAY);
}

function updateIoLogCopyStatus(message, variant = 'info') {
  const statusEl = document.getElementById('ioLogCopyStatus');
  if (!statusEl) return;
  if (ioLogCopyStatusTimer) {
    clearTimeout(ioLogCopyStatusTimer);
    ioLogCopyStatusTimer = null;
  }
  const baseClass = 'io-log-copy-status';
  statusEl.className = message && variant !== 'info' ? `${baseClass} ${variant}` : baseClass;
  statusEl.textContent = message || '';
  if (message) {
    ioLogCopyStatusTimer = setTimeout(() => {
      statusEl.textContent = '';
      statusEl.className = baseClass;
      ioLogCopyStatusTimer = null;
    }, 4000);
  }
}

function setIoLogPinned(pinned) {
  ioLogPinned = !!pinned;
  updateIoLogPanelPinnedState();
  if (ioLogPinned && ioLogHideTimer) {
    clearTimeout(ioLogHideTimer);
    ioLogHideTimer = null;
  }
  if (!ioLogPinned && !ioLogSession) {
    scheduleIoLogHide();
  }
}

function exportIoLog() {
  const list = document.getElementById('ioLogList');
  if (!list) return '';
  const items = Array.from(list.querySelectorAll('.io-log-step'));
  if (!items.length) {
    return '';
  }
  return items
    .map((item, idx) => {
      const state = item.dataset.state || 'pending';
      const messageEl = item.querySelector('.io-log-message');
      const detailEl = item.querySelector('.io-log-detail');
      const stateLabel = state === 'completed' ? 'OK' : state === 'aborted' ? 'ERREUR' : 'EN COURS';
      let text = `${idx + 1}. [${stateLabel}] ${messageEl ? messageEl.textContent : ''}`;
      if (detailEl && detailEl.textContent) {
        text += `\n    ${detailEl.textContent.split('\n').join('\n    ')}`;
      }
      return text;
    })
    .join('\n');
}

async function copyIoLogToClipboard() {
  const text = exportIoLog();
  if (!text) {
    updateIoLogCopyStatus('Aucune étape à copier pour le moment.');
    return;
  }
  try {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      await navigator.clipboard.writeText(text);
    } else {
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.setAttribute('readonly', '');
      textarea.style.position = 'fixed';
      textarea.style.top = '-1000px';
      textarea.style.opacity = '0';
      document.body.appendChild(textarea);
      textarea.select();
      const successful = document.execCommand('copy');
      document.body.removeChild(textarea);
      if (!successful) {
        throw new Error('execCommand copy failed');
      }
    }
    updateIoLogCopyStatus('Journal copié dans le presse-papiers.', 'success');
  } catch (err) {
    console.warn('Impossible de copier le journal IO', err);
    updateIoLogCopyStatus('Copie impossible. Consultez la console pour le journal.', 'error');
    console.log('--- Journal IO ---\n' + text);
  }
}

function startIoLogSession(kind, options = {}) {
  const list = document.getElementById('ioLogList');
  const titleEl = document.getElementById('ioLogTitle');
  if (!list || !titleEl) return;
  if (ioLogHideTimer) {
    clearTimeout(ioLogHideTimer);
    ioLogHideTimer = null;
  }
  const mode = options.mode || (kind === 'save' ? 'save' : 'add');
  const defaultTitle = kind === 'input'
    ? 'Ajout d’une entrée'
    : kind === 'output'
      ? 'Ajout d’une sortie'
      : 'Suivi de la configuration';
  const title = options.title || defaultTitle;
  ioLogSession = { kind, mode };
  list.innerHTML = '';
  titleEl.textContent = title;
  updateIoLogCopyStatus('');
  updateIoLogStepCounter();
  showIoLogPanel();
}

function appendIoLogStep(message, detail) {
  if (!ioLogSession) return null;
  const list = document.getElementById('ioLogList');
  if (!list) return null;
  const pendingItems = list.querySelectorAll('.io-log-step.pending');
  pendingItems.forEach(item => markIoLogStepCompleted(item));
  const item = document.createElement('li');
  item.className = 'io-log-step pending';
  item.dataset.state = 'pending';
  const icon = document.createElement('span');
  icon.className = 'io-log-icon';
  icon.textContent = '…';
  icon.setAttribute('aria-hidden', 'true');
  const content = document.createElement('div');
  content.className = 'io-log-content';
  const messageEl = document.createElement('div');
  messageEl.className = 'io-log-message';
  messageEl.textContent = message;
  content.appendChild(messageEl);
  if (detail !== undefined) {
    const detailEl = document.createElement('div');
    detailEl.className = 'io-log-detail';
    let detailText;
    if (typeof detail === 'object') {
      try {
        detailText = JSON.stringify(detail, null, 2);
      } catch (err) {
        detailText = String(detail);
      }
    } else {
      detailText = String(detail);
    }
    detailEl.textContent = detailText;
    content.appendChild(detailEl);
  }
  item.appendChild(icon);
  item.appendChild(content);
  list.appendChild(item);
  list.scrollTop = list.scrollHeight;
  showIoLogPanel();
  if (ioLogHideTimer) {
    clearTimeout(ioLogHideTimer);
    ioLogHideTimer = null;
  }
  updateIoLogStepCounter();
  updateIoLogCopyStatus('');
  return item;
}

function markIoLogStepCompleted(item, highlight = false) {
  if (!item || item.classList.contains('completed')) return;
  item.classList.remove('pending');
  item.classList.remove('aborted');
  item.classList.add('completed');
  item.dataset.state = 'completed';
  if (highlight) {
    item.classList.add('io-log-highlight');
  }
  const icon = item.querySelector('.io-log-icon');
  if (icon) {
    icon.textContent = '✓';
    icon.setAttribute('aria-hidden', 'true');
  }
}

function markIoLogStepAborted(item) {
  if (!item || item.classList.contains('aborted')) return;
  item.classList.remove('pending');
  item.classList.add('aborted');
  item.dataset.state = 'aborted';
  const icon = item.querySelector('.io-log-icon');
  if (icon) {
    icon.textContent = '✕';
    icon.setAttribute('aria-hidden', 'true');
  }
}

function completeIoLogSession(finalMessage) {
  if (!ioLogSession) return;
  const list = document.getElementById('ioLogList');
  if (list) {
    const pendingItems = list.querySelectorAll('.io-log-step.pending');
    pendingItems.forEach(item => markIoLogStepCompleted(item));
    if (finalMessage) {
      const finalItem = appendIoLogStep(finalMessage);
      if (finalItem) {
        markIoLogStepCompleted(finalItem, true);
      }
    }
  }
  ioLogSession = null;
  scheduleIoLogHide();
}

function cancelIoLogSession(reason) {
  if (!ioLogSession) return;
  const list = document.getElementById('ioLogList');
  if (list) {
    const pendingItems = list.querySelectorAll('.io-log-step.pending');
    pendingItems.forEach(item => markIoLogStepAborted(item));
    if (reason) {
      const cancelItem = appendIoLogStep(reason);
      if (cancelItem) {
        markIoLogStepAborted(cancelItem);
      }
    }
  }
  ioLogSession = null;
  scheduleIoLogHide();
}

function getSnapshotMap(kind) {
  return kind === 'input' ? lastAppliedInputs : lastAppliedOutputs;
}

function refreshModuleStateFromForm() {
  const modAds = document.getElementById('modAds');
  const modPwm = document.getElementById('modPwm');
  const modDac = document.getElementById('modDac');
  const modZmpt = document.getElementById('modZmpt');
  const modZmct = document.getElementById('modZmct');
  const modDiv = document.getElementById('modDiv');
  moduleState.ads1115 = !!(modAds && modAds.checked);
  moduleState.pwm010 = !!(modPwm && modPwm.checked);
  moduleState.mcp4725 = !!(modDac && modDac.checked);
  moduleState.zmpt = !!(modZmpt && modZmpt.checked);
  moduleState.zmct = !!(modZmct && modZmct.checked);
  moduleState.div = !!(modDiv && modDiv.checked);
}

function isTypeAvailable(kind, type) {
  if (type === 'disabled') {
    return true;
  }
  if (kind === 'input') {
    if (type === 'adc' || type === 'remote') {
      return true;
    }
    const moduleKey = MODULE_DEPENDENCIES.input[type];
    if (!moduleKey) {
      return true;
    }
    return !!moduleState[moduleKey];
  }
  if (type === 'gpio') {
    return true;
  }
  const moduleKey = MODULE_DEPENDENCIES.output[type];
  if (!moduleKey) {
    return true;
  }
  return !!moduleState[moduleKey];
}

function typeOptionsForKind(kind) {
  const source = kind === 'input' ? INPUT_TYPES : OUTPUT_TYPES;
  return source.filter(opt => isTypeAvailable(kind, opt.value));
}

function firstAvailableType(kind) {
  const options = typeOptionsForKind(kind);
  if (options.length > 0) {
    return options[0].value;
  }
  return 'disabled';
}

function gatherUsedPins(kind, typeSet, excludeIndex) {
  const used = new Set();
  const list = kind === 'input' ? inputs : outputs;
  list.forEach((item, idx) => {
    if (!item || idx === excludeIndex) {
      return;
    }
    if (!item.active || !item.pin) {
      return;
    }
    if (typeSet.has(item.type)) {
      used.add(item.pin);
    }
  });
  return used;
}

function availablePinsForInput(data, index) {
  if (!ANALOG_TYPES.has(data.type)) {
    return [];
  }
  const basePins = Array.from(new Set([...ANALOG_PINS, ...DIGITAL_PINS]));
  const used = gatherUsedPins('input', ANALOG_TYPES, index);
  return basePins.filter(pin => !used.has(pin) || data.pin === pin);
}

function availablePinsForOutput(data, index) {
  if (!OUTPUT_PIN_TYPES.has(data.type)) {
    return [];
  }
  const used = gatherUsedPins('output', OUTPUT_PIN_TYPES, index);
  return DIGITAL_PINS.filter(pin => !used.has(pin) || data.pin === pin);
}

function ensureTypeAvailability(kind) {
  const source = kind === 'input' ? inputs : outputs;
  let changed = false;
  source.forEach((item, idx) => {
    if (!item) return;
    if (isTypeAvailable(kind, item.type)) {
      return;
    }
    const previousName = item.name;
    logIoStep(`Type ${item.type} indisponible pour ${kind === 'input' ? 'entrée' : 'sortie'} ${previousName || (kind === 'input' ? `IN${idx + 1}` : `OUT${idx + 1}`)} — passage en mode désactivé.`);
    const replacement = kind === 'input' ? newInputConfig('disabled') : newOutputConfig('disabled');
    replacement.name = previousName;
    replacement.scale = item.scale;
    replacement.offset = item.offset;
    replacement.active = false;
    if (kind === 'input') {
      replacement.unit = item.unit || '';
    }
    source[idx] = replacement;
    const snapshot = kind === 'input' ? snapshotInput(replacement, idx) : snapshotOutput(replacement, idx);
    recordPendingSnapshot(kind, snapshot, previousName && previousName !== snapshot.name ? previousName : undefined);
    changed = true;
  });
  return changed;
}

function handleModuleStateChange() {
  refreshModuleStateFromForm();
  logIoStep('Mise à jour des modules optionnels', {
    ads1115: moduleState.ads1115,
    pwm010: moduleState.pwm010,
    mcp4725: moduleState.mcp4725,
    zmpt: moduleState.zmpt,
    zmct: moduleState.zmct,
    div: moduleState.div
  });
  const inputsChanged = ensureTypeAvailability('input');
  const outputsChanged = ensureTypeAvailability('output');
  if (inputsChanged || outputsChanged) {
    logIoStep('Certaines voies ont été désactivées suite au changement de modules.');
  }
  renderIoList('input');
  renderIoList('output');
  if (modalState) {
    applyTypeChange(modalState.kind, modalState.data.type);
    renderModalForm();
  }
}

function snapshotInput(item, idx) {
  const name = item.name && item.name.trim().length ? item.name.trim() : `IN${idx + 1}`;
  const snapshot = {
    name,
    type: item.type || 'disabled',
    active: !!item.active,
    scale: Number.isFinite(item.scale) ? item.scale : 1,
    offset: Number.isFinite(item.offset) ? item.offset : 0,
    unit: item.unit || ''
  };
  if (['adc', 'div', 'zmpt', 'zmct'].includes(snapshot.type)) {
    snapshot.pin = item.pin || '';
  }
  if (snapshot.type === 'ads1115') {
    const channel = Number.isFinite(item.adsChannel) ? parseInt(item.adsChannel, 10) : 0;
    snapshot.adsChannel = channel;
  }
  if (snapshot.type === 'remote') {
    snapshot.remoteNode = item.remoteNode || '';
    snapshot.remoteName = item.remoteName || '';
  }
  return snapshot;
}

function snapshotOutput(item, idx) {
  const name = item.name && item.name.trim().length ? item.name.trim() : `OUT${idx + 1}`;
  const snapshot = {
    name,
    type: item.type || 'disabled',
    active: !!item.active,
    scale: Number.isFinite(item.scale) ? item.scale : 1,
    offset: Number.isFinite(item.offset) ? item.offset : 0
  };
  if (['pwm010', 'gpio'].includes(snapshot.type)) {
    snapshot.pin = item.pin || '';
  }
  if (snapshot.type === 'pwm010') {
    snapshot.pwmFreq = Number.isFinite(item.pwmFreq) ? Math.max(1, Math.round(item.pwmFreq)) : 2000;
  }
  if (snapshot.type === 'mcp4725') {
    snapshot.i2cAddress = item.i2cAddress && item.i2cAddress.length ? item.i2cAddress : '0x60';
  }
  return snapshot;
}

function snapshotSignature(snapshot) {
  return JSON.stringify(snapshot);
}

function recordSyncedSnapshot(kind, snapshot) {
  const map = getSnapshotMap(kind);
  const signature = snapshotSignature(snapshot);
  map.set(snapshot.name, { state: STATUS_SYNCED, signature, saved: signature });
}

function recordPendingSnapshot(kind, snapshot, previousKey) {
  const map = getSnapshotMap(kind);
  let savedSignature = null;
  if (previousKey && previousKey !== snapshot.name) {
    const previousEntry = map.get(previousKey);
    if (previousEntry && typeof previousEntry.saved === 'string') {
      savedSignature = previousEntry.saved;
    }
    map.delete(previousKey);
  }
  const signature = snapshotSignature(snapshot);
  const existing = map.get(snapshot.name);
  if (existing) {
    if (existing.state === STATUS_SYNCED && existing.signature === signature) {
      map.set(snapshot.name, { state: STATUS_SYNCED, signature, saved: existing.saved || signature });
      return;
    }
    if (typeof existing.saved === 'string') {
      savedSignature = existing.saved;
    }
  }
  if (savedSignature !== null && savedSignature === signature) {
    map.set(snapshot.name, { state: STATUS_SYNCED, signature, saved: signature });
  } else {
    map.set(snapshot.name, { state: STATUS_PENDING, signature, saved: savedSignature });
  }
}

function removeSnapshot(kind, key) {
  const map = getSnapshotMap(kind);
  map.delete(key);
}

function resetSnapshotsFromConfig(kind, list) {
  const map = getSnapshotMap(kind);
  map.clear();
  list.forEach((item, idx) => {
    const snapshot = kind === 'input' ? snapshotInput(item, idx) : snapshotOutput(item, idx);
    recordSyncedSnapshot(kind, snapshot);
  });
}

function applyServerSnapshots(kind, entries) {
  const map = getSnapshotMap(kind);
  map.clear();
  if (!Array.isArray(entries)) return;
  entries.forEach(entry => {
    if (!entry || !entry.name) return;
    const signature = JSON.stringify(entry);
    map.set(entry.name, { state: STATUS_SYNCED, signature, saved: signature });
  });
}

function statusForSnapshot(kind, item, idx) {
  const snapshot = kind === 'input' ? snapshotInput(item, idx) : snapshotOutput(item, idx);
  const map = getSnapshotMap(kind);
  const entry = map.get(snapshot.name);
  const signature = snapshotSignature(snapshot);
  if (entry) {
    if (typeof entry.saved === 'string' && entry.saved === signature) {
      if (entry.state !== STATUS_SYNCED || entry.signature !== signature) {
        recordSyncedSnapshot(kind, snapshot);
      }
      return { className: 'synced', text: 'Synchronisé' };
    }
    if (entry.state === STATUS_PENDING) {
      return { className: 'pending', text: 'À enregistrer' };
    }
    if (entry.state === STATUS_SYNCED) {
      return { className: 'synced', text: 'Synchronisé' };
    }
  }
  return { className: 'pending', text: 'À enregistrer' };
}

function toNumber(value, fallback) {
  if (value === null || value === undefined) {
    return fallback;
  }
  if (typeof value === 'string') {
    const trimmed = value.trim();
    if (trimmed.length === 0) {
      return fallback;
    }
    value = trimmed;
  }
  const num = Number(value);
  return Number.isFinite(num) ? num : fallback;
}

function newInputConfig(type) {
  const resolvedType = isTypeAvailable('input', type) ? type : firstAvailableType('input');
  const cfg = {
    name: '',
    type: resolvedType,
    active: true,
    pin: '',
    adsChannel: 0,
    remoteNode: '',
    remoteName: '',
    scale: 1,
    offset: 0,
    unit: ''
  };
  if (ANALOG_TYPES.has(cfg.type)) {
    cfg.pin = 'A0';
  }
  if (cfg.type === 'ads1115') {
    cfg.adsChannel = 0;
  }
  if (cfg.type === 'disabled') {
    cfg.active = false;
  }
  return cfg;
}

function newOutputConfig(type) {
  const resolvedType = isTypeAvailable('output', type) ? type : firstAvailableType('output');
  const cfg = {
    name: '',
    type: resolvedType,
    active: true,
    pin: '',
    pwmFreq: 2000,
    i2cAddress: '0x60',
    scale: 1,
    offset: 0
  };
  if (cfg.type === 'pwm010') {
    cfg.pin = 'D2';
    cfg.pwmFreq = 2000;
  } else if (cfg.type === 'gpio') {
    cfg.pin = 'D1';
  } else if (cfg.type === 'disabled') {
    cfg.active = false;
  }
  return cfg;
}

function cloneConfig(obj) {
  return JSON.parse(JSON.stringify(obj));
}

function typeLabel(kind, value) {
  const source = kind === 'input' ? INPUT_TYPES : OUTPUT_TYPES;
  const found = source.find(o => o.value === value);
  return found ? found.label : value;
}

function normaliseInput(data) {
  const requestedType = data.type || 'disabled';
  const availableType = isTypeAvailable('input', requestedType) ? requestedType : firstAvailableType('input');
  if (requestedType !== availableType) {
    logIoStep(`Type ${requestedType} indisponible à l'import, utilisation de ${availableType}.`);
  }
  const base = newInputConfig(availableType);
  base.name = data.name || '';
  base.active = !!data.active;
  base.pin = data.pin || base.pin;
  const channel = parseInt(data.adsChannel, 10);
  base.adsChannel = Number.isFinite(channel) ? channel : base.adsChannel;
  base.remoteNode = data.remoteNode || '';
  base.remoteName = data.remoteName || '';
  base.scale = toNumber(data.scale, 1);
  base.offset = toNumber(data.offset, 0);
  base.unit = data.unit || '';
  return base;
}

function normaliseOutput(data) {
  const requestedType = data.type || 'disabled';
  const availableType = isTypeAvailable('output', requestedType) ? requestedType : firstAvailableType('output');
  if (requestedType !== availableType) {
    logIoStep(`Type ${requestedType} indisponible à l'import pour une sortie, utilisation de ${availableType}.`);
  }
  const base = newOutputConfig(availableType);
  base.name = data.name || '';
  base.active = !!data.active;
  base.pin = data.pin || base.pin;
  base.pwmFreq = Math.max(1, Math.round(toNumber(data.pwmFreq, base.pwmFreq)));
  base.i2cAddress = data.i2cAddress || base.i2cAddress;
  base.scale = toNumber(data.scale, 1);
  base.offset = toNumber(data.offset, 0);
  return base;
}

function updateIoCounters() {
  const inCounter = document.getElementById('inputsCounter');
  if (inCounter) inCounter.textContent = `${inputs.length} / ${MAX_INPUTS}`;
  const outCounter = document.getElementById('outputsCounter');
  if (outCounter) outCounter.textContent = `${outputs.length} / ${MAX_OUTPUTS}`;
}

function describeInput(item, index) {
  const fallbackName = item && item.name && item.name.trim()
    ? item.name.trim()
    : `IN${(index != null ? index : 0) + 1}`;
  const explanation = getIoExplanation('input', item || {}, fallbackName, index);
  const details = explanation.lines.slice();
  if (item && ['adc','div','zmpt','zmct'].includes(item.type) && item.pin) {
    details.push(`Broche utilisée : ${item.pin}`);
  }
  if (item && item.type === 'ads1115') {
    details.push(`Canal ADS1115 : A${item.adsChannel}`);
  }
  if (item && item.type === 'remote') {
    if (item.remoteNode) details.push(`Nœud distant : ${item.remoteNode}`);
    if (item.remoteName) details.push(`Nom distant : ${item.remoteName}`);
  }
  if (item && Number.isFinite(item.scale)) {
    details.push(`Échelle appliquée : ${item.scale}`);
  }
  if (item && Number.isFinite(item.offset)) {
    details.push(`Décalage appliqué : ${item.offset}`);
  }
  if (item && item.unit) {
    details.push(`Unité de restitution : ${item.unit}`);
  }
  return details;
}

function describeOutput(item, index) {
  const fallbackName = item && item.name && item.name.trim()
    ? item.name.trim()
    : `OUT${(index != null ? index : 0) + 1}`;
  const explanation = getIoExplanation('output', item || {}, fallbackName, index);
  const details = explanation.lines.slice();
  if (item && (item.type === 'pwm010' || item.type === 'gpio') && item.pin) {
    details.push(`Broche utilisée : ${item.pin}`);
  }
  if (item && item.type === 'pwm010') {
    details.push(`Fréquence PWM : ${item.pwmFreq} Hz`);
  }
  if (item && item.type === 'mcp4725') {
    details.push(`Adresse I²C : ${item.i2cAddress}`);
  }
  if (item && Number.isFinite(item.scale)) {
    details.push(`Échelle appliquée : ${item.scale}`);
  }
  if (item && Number.isFinite(item.offset)) {
    details.push(`Décalage appliqué : ${item.offset}`);
  }
  return details;
}

function renderIoList(kind) {
  const listEl = document.getElementById(kind === 'input' ? 'inputsList' : 'outputsList');
  if (!listEl) return;
  const source = kind === 'input' ? inputs : outputs;
  listEl.innerHTML = '';
  if (!source.length) {
    const empty = document.createElement('div');
    empty.className = 'io-empty';
    empty.textContent = kind === 'input' ? 'Aucune entrée configurée.' : 'Aucune sortie configurée.';
    listEl.appendChild(empty);
    updateIoCounters();
    return;
  }
  source.forEach((item, idx) => {
    const card = document.createElement('div');
    card.className = 'io-card';
    const header = document.createElement('div');
    header.className = 'io-card-header';
    const title = document.createElement('h3');
    title.textContent = item.name || (kind === 'input' ? `Entrée ${idx + 1}` : `Sortie ${idx + 1}`);
    header.appendChild(title);
    const controls = document.createElement('div');
    const typeLabelEl = document.createElement('div');
    typeLabelEl.className = 'io-type';
    typeLabelEl.textContent = typeLabel(kind, item.type);
    controls.appendChild(typeLabelEl);
    const toggleLabel = document.createElement('label');
    toggleLabel.className = 'toggle';
    const toggle = document.createElement('input');
    toggle.type = 'checkbox';
    toggle.checked = !!item.active;
    toggle.addEventListener('change', () => {
      item.active = toggle.checked;
      const snapshot = kind === 'input' ? snapshotInput(item, idx) : snapshotOutput(item, idx);
      const signature = snapshotSignature(snapshot);
      const map = getSnapshotMap(kind);
      const entry = map.get(snapshot.name);
      if (entry && entry.state === STATUS_SYNCED && entry.signature === signature) {
        recordSyncedSnapshot(kind, snapshot);
      } else {
        recordPendingSnapshot(kind, snapshot);
      }
      renderIoList(kind);
    });
    toggleLabel.appendChild(toggle);
    toggleLabel.appendChild(document.createTextNode(' Actif'));
    controls.appendChild(toggleLabel);
    const statusInfo = statusForSnapshot(kind, item, idx);
    const statusEl = document.createElement('span');
    statusEl.className = `io-status ${statusInfo.className}`;
    statusEl.textContent = statusInfo.text;
    controls.appendChild(statusEl);
    header.appendChild(controls);
    card.appendChild(header);
    const detailList = document.createElement('ul');
    detailList.className = 'io-details';
    const lines = kind === 'input' ? describeInput(item, idx) : describeOutput(item, idx);
    lines.forEach(text => {
      const li = document.createElement('li');
      li.textContent = text;
      detailList.appendChild(li);
    });
    card.appendChild(detailList);
    const actions = document.createElement('div');
    actions.className = 'io-actions';
    const editBtn = document.createElement('button');
    editBtn.type = 'button';
    editBtn.className = 'secondary';
    editBtn.textContent = 'Modifier';
    editBtn.addEventListener('click', () => openIoModal(kind, idx));
    actions.appendChild(editBtn);
    const delBtn = document.createElement('button');
    delBtn.type = 'button';
    delBtn.className = 'danger';
    delBtn.textContent = 'Supprimer';
    delBtn.addEventListener('click', () => {
      if (confirm('Supprimer cette configuration ?')) {
        if (kind === 'input') {
          const removed = inputs.splice(idx, 1)[0];
          if (removed) {
            const snap = snapshotInput(removed, idx);
            removeSnapshot('input', snap.name);
          }
          renderIoList('input');
        } else {
          const removed = outputs.splice(idx, 1)[0];
          if (removed) {
            const snap = snapshotOutput(removed, idx);
            removeSnapshot('output', snap.name);
          }
          renderIoList('output');
        }
      }
    });
    actions.appendChild(delBtn);
    card.appendChild(actions);
    listEl.appendChild(card);
  });
  updateIoCounters();
}

function openIoModal(kind, index) {
  const modal = document.getElementById('ioModal');
  if (!modal) return;
  let data;
  if (index != null) {
    const source = kind === 'input' ? inputs : outputs;
    data = cloneConfig(source[index]);
  } else {
    const defaults = kind === 'input' ? newInputConfig(firstAvailableType('input')) : newOutputConfig(firstAvailableType('output'));
    defaults.name = kind === 'input' ? `IN${inputs.length + 1}` : `OUT${outputs.length + 1}`;
    data = defaults;
  }
  modalState = { kind, index, data };
  logIoStep(`Ouverture du formulaire ${kind === 'input' ? 'entrée' : 'sortie'}`, { index, type: data.type });
  renderModalForm();
  modal.classList.remove('hidden');
}

function closeIoModal(cancelled = false) {
  const modal = document.getElementById('ioModal');
  if (modal) {
    modal.classList.add('hidden');
  }
  if (cancelled && ioLogSession && ioLogSession.mode === 'add') {
    cancelIoLogSession('Ajout annulé');
  }
  modalState = null;
}

function applyTypeChange(kind, newType) {
  if (!modalState) return;
  const old = modalState.data;
  if (!isTypeAvailable(kind, newType)) {
    logIoStep(`Type ${newType} indisponible pour ${kind}, sélection automatique ignorée.`);
    newType = firstAvailableType(kind);
  }
  if (old.type === newType) return;
  const defaults = kind === 'input' ? newInputConfig(newType) : newOutputConfig(newType);
  defaults.name = old.name;
  defaults.active = old.active;
  if ('scale' in old) defaults.scale = old.scale;
  if ('offset' in old) defaults.offset = old.offset;
  if (kind === 'input') {
    defaults.unit = old.unit;
  }
  logIoStep(`Changement de type ${kind === 'input' ? 'entrée' : 'sortie'}: ${old.type} → ${newType}`);
  modalState.data = defaults;
}

function renderTypeSpecificFields(data, kind) {
  const container = document.getElementById('modalTypeFields');
  if (!container) return;
  container.innerHTML = '';
  if (kind === 'input') {
    if (ANALOG_TYPES.has(data.type)) {
      const row = document.createElement('div');
      row.className = 'modal-form-row';
      const label = document.createElement('label');
      label.textContent = 'Entrée analogique';
      const select = document.createElement('select');
      const availablePins = availablePinsForInput(data, modalState ? modalState.index : -1);
      if (!data.pin || !availablePins.includes(data.pin)) {
        data.pin = availablePins.length ? availablePins[0] : '';
      }
      if (availablePins.length === 0) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = 'Aucune broche disponible';
        select.appendChild(opt);
        select.disabled = true;
        logIoStep('Aucune broche analogique disponible pour la nouvelle entrée.');
      } else {
        availablePins.forEach(pin => {
          const opt = document.createElement('option');
          opt.value = pin;
          opt.textContent = pin;
          select.appendChild(opt);
        });
        select.value = data.pin;
      }
      select.onchange = (ev) => {
        modalState.data.pin = ev.target.value;
      };
      row.appendChild(label);
      row.appendChild(select);
      container.appendChild(row);
    } else if (data.type === 'ads1115') {
      const row = document.createElement('div');
      row.className = 'modal-form-row';
      const label = document.createElement('label');
      label.textContent = 'Canal ADS1115';
      const select = document.createElement('select');
      [0,1,2,3].forEach(ch => {
        const opt = document.createElement('option');
        opt.value = ch;
        opt.textContent = `A${ch}`;
        select.appendChild(opt);
      });
      select.value = Number.isFinite(data.adsChannel) ? data.adsChannel : 0;
      select.onchange = (ev) => {
        modalState.data.adsChannel = parseInt(ev.target.value, 10);
      };
      row.appendChild(label);
      row.appendChild(select);
      container.appendChild(row);
    } else if (data.type === 'remote') {
      const rowNode = document.createElement('div');
      rowNode.className = 'modal-form-row';
      const labelNode = document.createElement('label');
      labelNode.textContent = 'Nœud distant';
      const inputNode = document.createElement('input');
      inputNode.type = 'text';
      inputNode.value = data.remoteNode || '';
      inputNode.oninput = (ev) => {
        modalState.data.remoteNode = ev.target.value.trim();
      };
      rowNode.appendChild(labelNode);
      rowNode.appendChild(inputNode);
      container.appendChild(rowNode);
      const rowName = document.createElement('div');
      rowName.className = 'modal-form-row';
      const labelName = document.createElement('label');
      labelName.textContent = "Nom de l'entrée distante";
      const inputName = document.createElement('input');
      inputName.type = 'text';
      inputName.value = data.remoteName || '';
      inputName.oninput = (ev) => {
        modalState.data.remoteName = ev.target.value.trim();
      };
      rowName.appendChild(labelName);
      rowName.appendChild(inputName);
      container.appendChild(rowName);
    }
  } else {
    if (OUTPUT_PIN_TYPES.has(data.type)) {
      const row = document.createElement('div');
      row.className = 'modal-form-row';
      const label = document.createElement('label');
      label.textContent = 'Pin de sortie';
      const select = document.createElement('select');
      const availablePins = availablePinsForOutput(data, modalState ? modalState.index : -1);
      if (!data.pin || !availablePins.includes(data.pin)) {
        data.pin = availablePins.length ? availablePins[0] : '';
      }
      if (availablePins.length === 0) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = 'Aucune broche disponible';
        select.appendChild(opt);
        select.disabled = true;
        logIoStep('Aucune broche numérique libre pour la sortie demandée.');
      } else {
        availablePins.forEach(pin => {
          const opt = document.createElement('option');
          opt.value = pin;
          opt.textContent = pin;
          select.appendChild(opt);
        });
        select.value = data.pin;
      }
      select.onchange = (ev) => {
        modalState.data.pin = ev.target.value;
      };
      row.appendChild(label);
      row.appendChild(select);
      container.appendChild(row);
    }
    if (data.type === 'pwm010') {
      const row = document.createElement('div');
      row.className = 'modal-form-row';
      const label = document.createElement('label');
      label.textContent = 'Fréquence PWM (Hz)';
      const input = document.createElement('input');
      input.type = 'number';
      input.min = '1';
      input.max = '40000';
      input.value = data.pwmFreq || 2000;
      input.oninput = (ev) => {
        const value = parseInt(ev.target.value, 10);
        modalState.data.pwmFreq = Number.isFinite(value) ? value : 2000;
      };
      row.appendChild(label);
      row.appendChild(input);
      container.appendChild(row);
    }
    if (data.type === 'mcp4725') {
      const row = document.createElement('div');
      row.className = 'modal-form-row';
      const label = document.createElement('label');
      label.textContent = 'Adresse I²C (ex. 0x60)';
      const input = document.createElement('input');
      input.type = 'text';
      input.value = data.i2cAddress || '0x60';
      input.oninput = (ev) => {
        modalState.data.i2cAddress = ev.target.value.trim();
      };
      row.appendChild(label);
      row.appendChild(input);
      container.appendChild(row);
    }
  }
}

function renderModalInfoPanel(kind, data, indexHint) {
  const panel = document.getElementById('modalInfo');
  if (!panel) return;
  const effectiveIndex = indexHint != null ? indexHint : (kind === 'input' ? inputs.length : outputs.length);
  const fallback = data && data.name && data.name.trim().length
    ? data.name.trim()
    : defaultIoName(kind, effectiveIndex);
  const info = getIoExplanation(kind, data || {}, fallback, effectiveIndex);
  panel.innerHTML = '';
  const titleEl = document.createElement('h3');
  titleEl.textContent = info.title;
  panel.appendChild(titleEl);
  const summaryEl = document.createElement('p');
  summaryEl.textContent = info.summary;
  panel.appendChild(summaryEl);
  const listEl = document.createElement('ul');
  info.lines.forEach(text => {
    const li = document.createElement('li');
    li.textContent = text;
    listEl.appendChild(li);
  });
  panel.appendChild(listEl);
}

function renderModalForm() {
  if (!modalState) return;
  const { kind, index, data } = modalState;
  const title = document.getElementById('modalTitle');
  const description = document.getElementById('modalDescription');
  const nameInput = document.getElementById('modalName');
  const typeSelect = document.getElementById('modalType');
  const activeCheckbox = document.getElementById('modalActive');
  const scaleInput = document.getElementById('modalScale');
  const offsetInput = document.getElementById('modalOffset');
  const unitRow = document.getElementById('modalUnitRow');
  const unitInput = document.getElementById('modalUnit');
  if (!title || !description || !nameInput || !typeSelect || !activeCheckbox || !scaleInput || !offsetInput || !unitRow || !unitInput) {
    return;
  }
  title.textContent = index != null ? (kind === 'input' ? 'Modifier une entrée' : 'Modifier une sortie')
                                   : (kind === 'input' ? 'Ajouter une entrée' : 'Ajouter une sortie');
  description.textContent = kind === 'input'
    ? "Choisissez le type de mesure et ajustez l'échelle pour correspondre à vos capteurs."
    : "Sélectionnez le type de sortie et configurez les paramètres électriques adaptés à l'actionneur.";
  nameInput.value = data.name || '';
  nameInput.oninput = (ev) => {
    modalState.data.name = ev.target.value;
    renderModalInfoPanel(kind, modalState.data, index);
  };
  typeSelect.innerHTML = '';
  let options = typeOptionsForKind(kind);
  if (!options.length) {
    options = [{ value: 'disabled', label: 'Désactivée' }];
  }
  if (!isTypeAvailable(kind, data.type)) {
    const fallback = firstAvailableType(kind);
    logIoStep(`Type ${data.type} non disponible dans le formulaire, bascule vers ${fallback}.`);
    data.type = fallback;
  }
  options.forEach(opt => {
    const optionEl = document.createElement('option');
    optionEl.value = opt.value;
    optionEl.textContent = opt.label;
    typeSelect.appendChild(optionEl);
  });
  if (!data.type) {
    data.type = options[0].value;
  }
  typeSelect.value = data.type;
  typeSelect.onchange = (ev) => {
    applyTypeChange(kind, ev.target.value);
    renderModalForm();
  };
  activeCheckbox.checked = !!data.active;
  activeCheckbox.onchange = (ev) => {
    modalState.data.active = ev.target.checked;
  };
  scaleInput.value = data.scale != null ? data.scale : 1;
  scaleInput.oninput = (ev) => {
    const value = parseFloat(ev.target.value);
    modalState.data.scale = Number.isFinite(value) ? value : 1;
  };
  offsetInput.value = data.offset != null ? data.offset : 0;
  offsetInput.oninput = (ev) => {
    const value = parseFloat(ev.target.value);
    modalState.data.offset = Number.isFinite(value) ? value : 0;
  };
  if (kind === 'input') {
    unitRow.classList.remove('hidden');
    unitInput.value = data.unit || '';
    unitInput.oninput = (ev) => {
      modalState.data.unit = ev.target.value;
    };
  } else {
    unitRow.classList.add('hidden');
  }
  renderTypeSpecificFields(modalState.data, kind);
  renderModalInfoPanel(kind, modalState.data, index);
}

function handleModalSubmit(event) {
  event.preventDefault();
  if (!modalState) return;
  const { kind, index, data } = modalState;
  const isNew = index == null;
  if (!data.name || !data.name.trim()) {
    alert('Veuillez indiquer un nom.');
    return;
  }
  data.name = data.name.trim();
  logIoStep(`Enregistrement ${kind === 'input' ? 'entrée' : 'sortie'} ${data.name}`, { type: data.type, active: data.active });
  if (kind === 'input') {
    if (index != null) {
      const previous = inputs[index];
      const previousSnapshot = snapshotInput(previous, index);
      inputs[index] = data;
      const updatedSnapshot = snapshotInput(inputs[index], index);
      const prevKey = previousSnapshot.name;
      const newKey = updatedSnapshot.name;
      const newSignature = snapshotSignature(updatedSnapshot);
      const mapEntry = lastAppliedInputs.get(prevKey);
      if (prevKey === newKey && mapEntry && mapEntry.state === STATUS_SYNCED && mapEntry.signature === newSignature && snapshotSignature(previousSnapshot) === newSignature) {
        recordSyncedSnapshot('input', updatedSnapshot);
      } else {
        recordPendingSnapshot('input', updatedSnapshot, prevKey === newKey ? undefined : prevKey);
      }
    } else {
      inputs.push(data);
      const newIndex = inputs.length - 1;
      const snapshot = snapshotInput(inputs[newIndex], newIndex);
      recordPendingSnapshot('input', snapshot);
    }
    renderIoList('input');
  } else {
    if (index != null) {
      const previous = outputs[index];
      const previousSnapshot = snapshotOutput(previous, index);
      outputs[index] = data;
      const updatedSnapshot = snapshotOutput(outputs[index], index);
      const prevKey = previousSnapshot.name;
      const newKey = updatedSnapshot.name;
      const newSignature = snapshotSignature(updatedSnapshot);
      const mapEntry = lastAppliedOutputs.get(prevKey);
      if (prevKey === newKey && mapEntry && mapEntry.state === STATUS_SYNCED && mapEntry.signature === newSignature && snapshotSignature(previousSnapshot) === newSignature) {
        recordSyncedSnapshot('output', updatedSnapshot);
      } else {
        recordPendingSnapshot('output', updatedSnapshot, prevKey === newKey ? undefined : prevKey);
      }
    } else {
      outputs.push(data);
      const newIndex = outputs.length - 1;
      const snapshot = snapshotOutput(outputs[newIndex], newIndex);
      recordPendingSnapshot('output', snapshot);
    }
    renderIoList('output');
  }
  if (isNew && ioLogSession && ioLogSession.kind === kind) {
    completeIoLogSession(kind === 'input' ? 'Entrée vérifiée' : 'Sortie vérifiée');
  }
  closeIoModal(false);
}

function addInput() {
  if (inputs.length >= MAX_INPUTS) {
    alert(`Nombre maximum d'entrées atteint (${MAX_INPUTS}).`);
    return;
  }
  startIoLogSession('input');
  logIoStep('Initialisation de l\'ajout d\'une nouvelle entrée.');
  openIoModal('input', null);
}

function addOutput() {
  if (outputs.length >= MAX_OUTPUTS) {
    alert(`Nombre maximum de sorties atteint (${MAX_OUTPUTS}).`);
    return;
  }
  startIoLogSession('output');
  logIoStep('Initialisation de l\'ajout d\'une nouvelle sortie.');
  openIoModal('output', null);
}

// Load config from server and populate form
async function loadConfig() {
  try {
    const resp = await authFetch('/api/config/io/get');
    if (!resp.ok) throw new Error('Chargement impossible');
    const cfg = await resp.json();
    logIoStep('Configuration reçue du serveur');
    const metadata = cfg.metadata || {};
    const fwVersionEl = document.getElementById('fwVersion');
    if (fwVersionEl) {
      fwVersionEl.textContent = metadata.fwVersion || 'inconnue';
    }
    const modules = cfg.modules || {};
    document.getElementById('modAds').checked = !!modules.ads1115;
    document.getElementById('modPwm').checked = !!modules.pwm010;
    document.getElementById('modDac').checked = !!modules.mcp4725;
    document.getElementById('modZmpt').checked = !!modules.zmpt;
    document.getElementById('modZmct').checked = !!modules.zmct;
    document.getElementById('modDiv').checked = !!modules.div;
    refreshModuleStateFromForm();
    logIoStep('Modules synchronisés lors du chargement', { ...moduleState });
    inputs = Array.isArray(cfg.inputs) ? cfg.inputs.slice(0, MAX_INPUTS).map(normaliseInput) : [];
    outputs = Array.isArray(cfg.outputs) ? cfg.outputs.slice(0, MAX_OUTPUTS).map(normaliseOutput) : [];
    ensureTypeAvailability('input');
    ensureTypeAvailability('output');
    resetSnapshotsFromConfig('input', inputs);
    resetSnapshotsFromConfig('output', outputs);
    renderIoList('input');
    renderIoList('output');
    logIoStep('Configuration appliquée', { inputs: inputs.length, outputs: outputs.length });
  } catch (err) {
    console.error(err);
    logIoStep('Erreur lors du chargement de la configuration', err);
    document.getElementById('status').textContent = 'Erreur lors du chargement de la configuration.';
  }
}

// Serialize form to config JSON and post to server
async function saveConfig() {
  startIoLogSession('save', { title: 'Sauvegarde de la configuration', mode: 'save' });
  refreshModuleStateFromForm();
  logIoStep('Début de sauvegarde de la configuration', { ...moduleState });
  const cfg = {};
  cfg.modules = {
    ads1115: document.getElementById('modAds').checked,
    pwm010:  document.getElementById('modPwm').checked,
    mcp4725: document.getElementById('modDac').checked,
    zmpt:    document.getElementById('modZmpt').checked,
    zmct:    document.getElementById('modZmct').checked,
    div:     document.getElementById('modDiv').checked
  };
  cfg.inputs = inputs.slice(0, MAX_INPUTS).map((item, idx) => {
    const obj = {
      name: item.name || `IN${idx + 1}`,
      type: item.type,
      scale: Number.isFinite(item.scale) ? item.scale : 1,
      offset: Number.isFinite(item.offset) ? item.offset : 0,
      unit: item.unit || '',
      active: !!item.active
    };
    if (['adc','div','zmpt','zmct'].includes(item.type)) {
      obj.pin = item.pin || '';
    }
    if (item.type === 'ads1115') {
      obj.adsChannel = Number.isFinite(item.adsChannel) ? parseInt(item.adsChannel, 10) : 0;
    }
    if (item.type === 'remote') {
      obj.remoteNode = item.remoteNode || '';
      obj.remoteName = item.remoteName || '';
    }
    return obj;
  });
  cfg.inputCount = cfg.inputs.length;
  cfg.outputs = outputs.slice(0, MAX_OUTPUTS).map((item, idx) => {
    const obj = {
      name: item.name || `OUT${idx + 1}`,
      type: item.type,
      scale: Number.isFinite(item.scale) ? item.scale : 1,
      offset: Number.isFinite(item.offset) ? item.offset : 0,
      active: !!item.active
    };
    if (['pwm010','gpio'].includes(item.type)) {
      obj.pin = item.pin || '';
    }
    if (item.type === 'pwm010') {
      obj.pwmFreq = Number.isFinite(item.pwmFreq) ? Math.max(1, Math.round(item.pwmFreq)) : 2000;
    }
    if (item.type === 'mcp4725') {
      obj.i2cAddress = item.i2cAddress && item.i2cAddress.length ? item.i2cAddress : '0x60';
    }
    return obj;
  });
  cfg.outputCount = cfg.outputs.length;
  logIoStep('Configuration assemblée avant envoi', {
    inputs: cfg.inputs.length,
    outputs: cfg.outputs.length
  });
  const statusEl = document.getElementById('status');
  let payload;
  try {
    payload = JSON.stringify(cfg);
  } catch (err) {
    logIoStep('Erreur lors de la sérialisation JSON locale', { message: err.message });
    if (statusEl) {
      statusEl.textContent = 'Erreur lors de la préparation de la configuration.';
    }
    cancelIoLogSession('Séquence d’enregistrement interrompue');
    return;
  }
  const payloadPreview = payload.length > 800 ? `${payload.slice(0, 800)}…` : payload;
  logIoStep('JSON de configuration généré', {
    octets: payload.length,
    aperçu: payloadPreview
  });

  // Post config
  const requestOptions = {
    method: 'POST',
    headers: { 'Content-Type': 'text/plain' },
    body: payload
  };
  let currentEndpoint = '/api/config/io/set';
  logIoStep('Transmission de la configuration au serveur', { endpoint: currentEndpoint });

  async function sendConfigRequest(url) {
    const response = await authFetch(url, requestOptions);
    let raw = '';
    try {
      raw = await response.text();
    } catch (_) {
      raw = '';
    }
    let parsed = null;
    if (raw && raw.length) {
      try {
        parsed = JSON.parse(raw);
      } catch (_) {
        parsed = null;
      }
    }
    return { response, raw, parsed };
  }

  try {
    let attempt = await sendConfigRequest(currentEndpoint);
    let legacyEndpointUsed = false;
    if (attempt.response.status === 404) {
      logIoStep('Point de terminaison /api/config/io/set indisponible, tentative via /api/config/set.');
      legacyEndpointUsed = true;
      currentEndpoint = '/api/config/set';
      logIoStep('Transmission de la configuration au serveur', { endpoint: currentEndpoint, mode: 'compatibilité' });
      attempt = await sendConfigRequest(currentEndpoint);
    }

    const { response: resp, raw, parsed } = attempt;
    logIoStep('Analyse de la réponse du serveur', { status: resp.status, endpoint: currentEndpoint });
    if (resp.ok) {
      if (parsed && parsed.applied) {
        applyServerSnapshots('input', parsed.applied.inputs || []);
        applyServerSnapshots('output', parsed.applied.outputs || []);
        renderIoList('input');
        renderIoList('output');
      }
      if (legacyEndpointUsed) {
        logIoStep('Configuration sauvegardée via le point de terminaison historique /api/config/set.');
      } else {
        logIoStep('Configuration sauvegardée avec succès');
      }
      if (statusEl) {
        statusEl.textContent = legacyEndpointUsed
          ? 'Sauvegarde vérifiée (mode compatibilité), redémarrage...'
          : 'Sauvegarde vérifiée, redémarrage...';
      }
      const finalMessage = legacyEndpointUsed
        ? 'Séquence d’enregistrement validée (compatibilité)'
        : 'Séquence d’enregistrement validée';
      completeIoLogSession(finalMessage);
    } else {
      let message = 'Erreur lors de la sauvegarde';
      if (parsed && parsed.error) {
        if (parsed.detail) {
          message = `Erreur lors de la sauvegarde (${parsed.error}: ${parsed.detail})`;
        } else {
          message = `Erreur lors de la sauvegarde (${parsed.error})`;
        }
      } else if (raw && raw.length) {
        message = `Erreur lors de la sauvegarde (${raw})`;
      }
      if (legacyEndpointUsed) {
        message += ' — tentative via /api/config/set.';
      }
      if (parsed) {
        logIoStep('Réponse JSON du serveur', { status: resp.status, json: parsed });
      } else if (raw && raw.length) {
        const responsePreview = raw.length > 800 ? `${raw.slice(0, 800)}…` : raw;
        logIoStep('Réponse texte du serveur', {
          status: resp.status,
          octets: raw.length,
          aperçu: responsePreview
        });
      }
      logIoStep('Échec de la sauvegarde', { status: resp.status, message });
      if (statusEl) {
        statusEl.textContent = message;
      }
      cancelIoLogSession('Séquence d’enregistrement interrompue');
    }
  } catch (err) {
    console.error(err);
    logIoStep('Exception lors de la sauvegarde', err);
    if (statusEl) {
      statusEl.textContent = 'Erreur lors de la sauvegarde';
    }
    cancelIoLogSession('Séquence d’enregistrement interrompue');
  }
}

// Show/hide STA config depending on mode
// Event listeners
window.addEventListener('DOMContentLoaded', () => {
  refreshModuleStateFromForm();
  const addInputBtn = document.getElementById('addInputBtn');
  if (addInputBtn) {
    addInputBtn.addEventListener('click', addInput);
  }
  const addOutputBtn = document.getElementById('addOutputBtn');
  if (addOutputBtn) {
    addOutputBtn.addEventListener('click', addOutput);
  }
  ['modAds','modPwm','modDac','modZmpt','modZmct','modDiv'].forEach(id => {
    const checkbox = document.getElementById(id);
    if (checkbox) {
      checkbox.addEventListener('change', handleModuleStateChange);
    }
  });
  const modalForm = document.getElementById('modalForm');
  if (modalForm) {
    modalForm.addEventListener('submit', handleModalSubmit);
  }
  const modalCancel = document.getElementById('modalCancel');
  if (modalCancel) {
    modalCancel.addEventListener('click', () => closeIoModal(true));
  }
  const modal = document.getElementById('ioModal');
  if (modal) {
    modal.addEventListener('click', (ev) => {
      if (ev.target === modal) {
        closeIoModal(true);
      }
    });
  }
  window.addEventListener('keydown', (ev) => {
    if (ev.key === 'Escape') {
      if (modalState) {
        closeIoModal(true);
      } else if (!ioLogPinned) {
        hideIoLogPanel(true);
      }
    }
  });
  const ioLogCopyBtn = document.getElementById('ioLogCopyBtn');
  if (ioLogCopyBtn) {
    ioLogCopyBtn.addEventListener('click', () => {
      copyIoLogToClipboard();
    });
  }
  const ioLogPinCheckbox = document.getElementById('ioLogPin');
  if (ioLogPinCheckbox) {
    ioLogPinCheckbox.addEventListener('change', (event) => {
      setIoLogPinned(!!event.target.checked);
    });
  }
  const ioLogCloseBtn = document.getElementById('ioLogCloseBtn');
  if (ioLogCloseBtn) {
    ioLogCloseBtn.addEventListener('click', () => {
      setIoLogPinned(false);
      hideIoLogPanel(true);
    });
  }
  const ioLogOverlay = document.getElementById('ioLogOverlay');
  if (ioLogOverlay) {
    ioLogOverlay.addEventListener('click', (ev) => {
      if (ev.target === ioLogOverlay && !ioLogPinned) {
        hideIoLogPanel(true);
      }
    });
  }
  const ioLogPanelEl = document.getElementById('ioLogPanel');
  if (ioLogPanelEl) {
    ioLogPanelEl.addEventListener('click', (ev) => {
      ev.stopPropagation();
    });
  }
  updateIoLogPanelPinnedState();
  updateIoLogStepCounter();
  renderIoList('input');
  renderIoList('output');
  ensureSession()
    .then(() => {
      loadConfig();
    })
    .catch(err => {
      console.error(err);
    });
  document.getElementById('saveBtn').addEventListener('click', () => {
    document.getElementById('status').textContent = 'Sauvegarde...';
    saveConfig();
  });
  document.getElementById('rebootBtn').addEventListener('click', () => {
    document.getElementById('fwStatus').textContent = 'Redémarrage...';
    authFetch('/api/reboot', {method: 'POST'});
  });
  document.getElementById('fwUploadBtn').addEventListener('click', async () => {
    const file = document.getElementById('fwFile').files[0];
    const st = document.getElementById('fwStatus');
    if (!file) { st.textContent = 'Choisir un fichier'; return; }
    const formData = new FormData();
    formData.append('firmware', file, file.name);
    st.textContent = 'Téléversement...';
    try {
      const resp = await authFetch('/api/ota', {method: 'POST', body: formData});
      if (resp.ok) {
        st.textContent = 'Mise à jour envoyée, redémarrage...';
      } else {
        let message = 'Échec de la mise à jour';
        try {
          const data = await resp.clone().json();
          if (data && data.error) {
            message = `Échec de la mise à jour (${data.error})`;
          }
        } catch (jsonErr) {
          try {
            const text = await resp.text();
            if (text) {
              message = `Échec de la mise à jour (${text})`;
            }
          } catch (_) {
            // Ignore text parsing errors
          }
        }
        st.textContent = message;
      }
    } catch (err) {
      st.textContent = 'Erreur de mise à jour';
    }
  });
});
</script>
</body>
</html>
